<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TaktLab – Cycle Time & Capacity Analyzer</title>
<style>
  :root{
    --bg-main:#07152b;
    --bg-card:#0b1f3a;
    --bg-card-soft:#0f2544;
    --accent-green:#00c853;
    --accent-amber:#ffb300;
    --accent-red:#ff1744;
    --accent-blue:#29b6f6;
    --accent-grey:#cfd8dc;
    --text-main:#ffffff;
    --text-soft:#c5cae9;
    --text-muted:#90a4ae;
    --border-soft:#1c3357;
    --btn-green:#00c853;
    --btn-orange:#ff9100;
    --btn-grey:#455a64;
    --badge-green:#004d40;
    --badge-red:#b71c1c;
    --badge-amber:#ff8f00;
  }

  *{box-sizing:border-box;}

  body{
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 40%,#020b1a 100%);
    color:var(--text-main);
  }

  .page{
    max-width:1100px;
    margin:0 auto;
    padding:12px 10px 40px;
  }

  .sticky-timer-bar{
    position:sticky;
    top:0;
    z-index:100;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 90%);
    padding:8px 0 10px;
  }

  .top-row{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
  }

  .logo-circle{
    width:38px;
    height:38px;
    border-radius:50%;
    border:2px solid var(--accent-grey);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .logo-gear{
    width:22px;
    height:22px;
    border-radius:50%;
    border:2px solid var(--accent-grey);
    position:relative;
  }
  .logo-gear::before{
    content:"";
    position:absolute;
    inset:4px;
    border-radius:50%;
    border:2px solid var(--accent-green);
    border-right-color:transparent;
    border-bottom-color:transparent;
    transform-origin:50% 50%;
  }
  .logo-gear.spinning::before{ animation:logo-spin 2s linear infinite; }
  @keyframes logo-spin{ from{transform:rotate(0deg);} to{transform:rotate(360deg);} }

  .title-block{display:flex;flex-direction:column;gap:2px;}
  .title-main{font-size:1.2rem;font-weight:700;letter-spacing:.03em;}
  .title-sub{font-size:.72rem;color:var(--text-soft);}

  .lang-switch{margin-left:auto;display:flex;align-items:center;gap:4px;}
  .lang-btn{
    border-radius:999px;border:1px solid var(--border-soft);
    background:rgba(2,11,26,.6);color:var(--text-soft);
    font-size:.7rem;padding:4px 8px;cursor:pointer;min-width:34px;
  }
  .lang-btn.active{background:var(--accent-blue);color:#fff;border-color:var(--accent-blue);font-weight:600;}

  .timer-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:6px 10px 10px;
    box-shadow:0 8px 18px rgba(0,0,0,.45);
  }

  .timer-display{
    text-align:center;
    font-size:2.8rem;
    font-weight:600;
    letter-spacing:.08em;
    padding:4px 4px 8px;
  }

  /* ===== Visual lines (semaforos) ===== */
  .info-stack{ display:flex; flex-direction:column; gap:6px; margin:0 0 8px; }
  .info-line{
    font-size:.78rem;margin:0;padding:6px 10px;
    border-radius:12px;border:1px solid transparent;
    line-height:1.25;
  }
  .sample-neutral{background:rgba(255,255,255,.03);border-color:rgba(255,255,255,.08);color:var(--text-soft);}
  .sample-good{background:rgba(0,200,83,.15);border-color:rgba(0,200,83,.7);color:#c8e6c9;}
  .sample-warn{background:rgba(255,193,7,.14);border-color:rgba(255,193,7,.8);color:#ffe082;}
  .sample-bad{background:rgba(244,67,54,.16);border-color:rgba(244,67,54,.9);color:#ffab91;}

  .btn-row-main{display:flex;gap:10px;margin-bottom:2px;}
  .btn{
    border:none;border-radius:16px;padding:10px 12px;
    font-size:.9rem;font-weight:600;cursor:pointer;color:#fff;
    box-shadow:0 4px 10px rgba(0,0,0,.4);flex:1;
    transition:transform .04s ease, box-shadow .04s ease, background .15s;
    touch-action:manipulation;
  }
  .btn:active{transform:translateY(1px);box-shadow:0 1px 4px rgba(0,0,0,.5);}
  .btn-start{background:var(--btn-green);}
  .btn-lap{background:var(--btn-orange);}

  .flash{animation:flash-bg .12s ease-out;}
  @keyframes flash-bg{ from{background:rgba(255,255,255,.18);} to{background:transparent;} }

  .content-section{margin-top:10px;}

  .section-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:10px 10px 12px;
    margin-bottom:10px;
  }
  .section-title{font-size:1.0rem;font-weight:700;margin-bottom:8px;}

  .mode-row{
    display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    font-size:.78rem;color:var(--text-soft);
  }
  .mode-row select,.mode-row input{
    background:#020b1a;border-radius:8px;border:1px solid var(--border-soft);
    padding:4px 8px;color:var(--text-soft);font-size:.78rem;min-width:70px;
  }
  .mode-row input[type="number"]{width:70px;}

  table{width:100%;border-collapse:collapse;font-size:.75rem;}
  th,td{
    padding:4px 6px;text-align:right;
    border-bottom:1px solid rgba(255,255,255,.04);
    white-space:nowrap;
    vertical-align:middle;
  }
  th:first-child,td:first-child{text-align:left;}
  th{
    color:var(--text-soft);font-weight:600;background:rgba(255,255,255,.02);
    position:sticky;top:0;z-index:5;
  }
  tbody tr:nth-child(even){background:rgba(255,255,255,.02);}

  .badge{
    display:inline-block;padding:2px 6px;border-radius:999px;
    font-size:.68rem;border:1px solid transparent;
  }
  .badge-good{background:var(--badge-green);border-color:#00e676;}
  .badge-warn{background:var(--badge-amber);border-color:#ffe082;color:#000;}
  .badge-bad{background:var(--badge-red);border-color:#ff8a80;}

  .btn-row-secondary{display:flex;flex-wrap:wrap;gap:10px;margin:8px 0 4px;}
  .btn-small{
    padding:10px 16px;border-radius:16px;font-size:.86rem;font-weight:700;
    flex:0 0 auto;background:var(--bg-card-soft);color:var(--text-soft);
    border:1px solid var(--border-soft);cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,.35);
  }
  .btn-small-copy{background:var(--accent-blue);border-color:var(--accent-blue);color:#fff;}
  .btn-small-summary{background:var(--accent-amber);border-color:var(--accent-amber);color:#000;}
  .btn-small-manual{background:var(--accent-green);border-color:var(--accent-green);color:#000;}
  .btn-small-reset{background:var(--accent-red);border-color:var(--accent-red);color:#fff;}
  .btn-small-wbadd{background:rgba(255,255,255,.06);color:var(--text-soft);}
  .btn-small-wbclear{background:rgba(255,23,68,.16);border-color:rgba(255,23,68,.6);color:#ff8a80;}

  .subsection-title{
    margin-top:10px;font-size:.82rem;font-weight:650;color:var(--text-soft);
  }

  .footer-note{margin-top:10px;font-size:.65rem;color:var(--text-muted);text-align:right;}

  .charts-wrapper{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:10px;
  }
  .chart-card{
    background:var(--bg-card-soft);
    border-radius:14px;
    border:1px solid var(--border-soft);
    padding:8px;
  }
  .chart-title{font-size:.75rem;margin-bottom:4px;color:var(--text-soft);}
  canvas{
    width:100%;height:180px;background:#020b1a;border-radius:10px;
  }

  .btn-edit,.btn-del{
    padding:2px 6px;border-radius:8px;font-size:.7rem;
    border:1px solid rgba(255,255,255,.2);cursor:pointer;background:transparent;
  }
  .btn-edit{color:#81d4fa;}
  .btn-del{color:#ff8a80;}

  /* WB inputs */
  .wb-inp, .wb-sel, .wb-chk{
    background:#020b1a;border-radius:8px;border:1px solid var(--border-soft);
    padding:3px 6px;color:var(--text-soft);font-size:.72rem;
  }
  .wb-inp{width:86px;}
  .wb-inp.wide{width:160px;}
  .wb-inp.slim{width:64px;}
  .wb-sel{width:94px;}
  .wb-pill{
    display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.03);font-size:.72rem;color:var(--text-soft);
  }
  .wb-alert{
    display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px;
  }
  .wb-alert .badge{font-size:.72rem;padding:4px 10px;}
  .wb-badge-title{font-size:.72rem;color:var(--text-soft);}
  .wb-mini{font-size:.7rem;color:var(--text-muted);line-height:1.25;margin-top:6px;}

  @media (max-width:600px){
    .timer-display{font-size:2.2rem;}
    .btn-row-main{gap:6px;}
    .btn{font-size:.9rem;border-radius:14px;}
    canvas{height:160px;}
    th,td{font-size:.72rem;}
    .wb-inp{width:78px;}
    .wb-inp.wide{width:140px;}
  }
</style>
</head>
<body>
<div class="page">

  <div class="sticky-timer-bar">
    <div class="top-row">
      <div class="logo-circle"><div class="logo-gear" id="logoGear"></div></div>
      <div class="title-block">
        <div class="title-main">TaktLab</div>
        <div class="title-sub" data-i18n="title.subtitle">Cycle Time &amp; Capacity Analyzer</div>
      </div>
      <div class="lang-switch">
        <button class="lang-btn" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="es">ES</button>
      </div>
    </div>

    <div class="timer-card" id="timerCard">
      <div class="timer-display" id="display">00:00.00</div>

      <!-- ✅ Debajo del cronómetro SOLO se queda Sample Size -->
      <div class="info-stack">
        <div class="info-line sample-neutral" id="sampleInfoTop">
          No samples yet for current process. Start capturing laps.
        </div>
      </div>

      <div class="btn-row-main">
        <button class="btn btn-start" id="btnStart" data-i18n="btn.start">Start</button>
        <button class="btn btn-lap" id="btnLap" data-i18n="btn.lap">LAP</button>
      </div>
    </div>
  </div>

  <div class="content-section">

    <div class="section-card">
      <div class="section-title" data-i18n="section.dataControls">Data Controls</div>
      <div class="btn-row-secondary">
        <button class="btn-small btn-small-copy" id="btnCopyAll" data-i18n="btn.copyAll">Copy All</button>
        <button class="btn-small btn-small-summary" id="btnCopySummary" data-i18n="btn.copySummary">Copy Summary</button>
        <button class="btn-small btn-small-manual" id="btnAddManualLap" data-i18n="btn.addManualLap">Add Manual Lap</button>
        <button class="btn-small btn-small-reset" id="btnReset" data-i18n="btn.reset">Reset</button>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.measurementSetup">Measurement Setup</div>

      <div class="mode-row">
        <div>
          <label for="processName" data-i18n="label.process">Process</label><br/>
          <input id="processName" type="text" placeholder="e.g. Op 30-1" data-i18n-placeholder="label.processPlaceholder"/>
        </div>

        <div>
          <label for="mode" data-i18n="label.mode">Mode</label><br/>
          <select id="mode">
            <option value="CT" data-i18n="mode.ct">Cycle Time (CT)</option>
            <option value="MLD" data-i18n="mode.mld">Machine &amp; Load/Unload</option>
          </select>
        </div>

        <div>
          <label for="efficiency" data-i18n="label.efficiency">Efficiency %</label><br/>
          <input id="efficiency" type="number" value="100" min="0" max="100" step="1"/>
        </div>

        <div>
          <label for="contractPcd" data-i18n="label.contractPcd">Contract Cap (pcs/day)</label><br/>
          <input id="contractPcd" type="number" min="0" step="1"/>
        </div>

        <div>
          <label for="hoursPerDay" data-i18n="label.hoursPerDay">Hours / Day</label><br/>
          <input id="hoursPerDay" type="number" value="8" min="1" max="24" step=".5"/>
        </div>

        <div>
          <label for="daysPerWeek" data-i18n="label.daysPerWeek">Days / Week</label><br/>
          <input id="daysPerWeek" type="number" value="5" min="1" max="7"/>
        </div>

        <div>
          <label for="capView" data-i18n="label.capView">Capacity View</label><br/>
          <select id="capView">
            <option value="hour" data-i18n="capView.hour">per Hour</option>
            <option value="day" data-i18n="capView.day">per Day</option>
            <option value="week" data-i18n="capView.week">per Week</option>
          </select>
        </div>
      </div>
    </div>
    <!-- ✅ ENFOQUE ESTADÍSTICO -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.statsFocus">Stat Focus</div>

      <!-- ✅ Los 3 bloques + duplicado de tamaño de muestra, aquí viven -->
      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="sampleInfoFocus">Sample size: —</div>
        <div class="info-line sample-neutral" id="stdInfoFocus">Std dev: —</div>
        <div class="info-line sample-neutral" id="distInfoFocus">Mean vs Median: —</div>
        <div class="info-line sample-neutral" id="contractInfoFocus">No contract loaded</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 6px;">
        <span data-i18n="stats.note">Simple language on purpose: few / enough samples, low / high variation, capable / not capable.</span>
      </div>

      <div style="max-height:320px;overflow:auto;">
        <table>
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th>N</th>
              <th data-i18n="col.sample">Sample size / Error</th>
              <th>Std</th>
              <th>CV%</th>
              <th>CTmed</th>
              <th>P10</th>
              <th>P90</th>
              <th data-i18n="col.capCurrent">Current @Eff</th>
              <th data-i18n="col.capPotential">Potential @Eff</th>
              <th data-i18n="col.capWorst">Worst @Eff</th>
              <th data-i18n="col.contract">Contract</th>
              <th data-i18n="col.gap">Gap</th>
              <th data-i18n="col.vsContract">% vs</th>
              <th>Cp</th>
              <th>Cpk</th>
              <th data-i18n="col.note">Note</th>
            </tr>
          </thead>
          <tbody id="focusBody"></tbody>
        </table>
      </div>

      <!-- ✅ WB / Capacity Planner -->
      <div class="subsection-title" data-i18n="section.wbPlanner">WB – Capacity Planner (by process)</div>

      <div class="btn-row-secondary" style="margin-top:8px;">
        <button class="btn-small btn-small-wbadd" id="btnWbAdd" data-i18n="btn.wbAdd">+ Add Operation</button>
        <button class="btn-small btn-small-wbclear" id="btnWbClear" data-i18n="btn.wbClear">Clear WB</button>
      </div>

      <div style="max-height:360px;overflow:auto;">
        <table id="wbTable">
          <thead>
            <tr>
              <th data-i18n="wb.seq">Seq</th>
              <th data-i18n="wb.enabled">On</th>
              <th data-i18n="wb.operation">Operation</th>
              <th data-i18n="wb.operators">Operators</th>
              <th data-i18n="wb.shifts">Shifts</th>
              <th data-i18n="wb.hours">Hours</th>
              <th data-i18n="wb.machines"># Machines</th>
              <th data-i18n="wb.contract">Contract (pcs/day)</th>

              <th data-i18n="wb.gross">Gross min/day</th>
              <th data-i18n="wb.lunch">Lunch min/day</th>
              <th data-i18n="wb.changeover">Changeover</th>
              <th data-i18n="wb.cleaning">5S/Clean</th>
              <th data-i18n="wb.maint">Maintenance</th>
              <th data-i18n="wb.other">Other</th>

              <th data-i18n="wb.udt">Unplanned DT</th>
              <th data-i18n="wb.udtUnit">Unit</th>

              <th data-i18n="wb.net">Net min/day</th>

              <th data-i18n="wb.scrap">Scrap %</th>
              <th data-i18n="wb.yield">Yield</th>

              <th data-i18n="wb.oeeA">A%</th>
              <th data-i18n="wb.oeeP">P%</th>
              <th data-i18n="wb.oeeQ">Q%</th>
              <th data-i18n="wb.oee">OEE%</th>

              <th data-i18n="wb.ctCur">CT Current</th>
              <th data-i18n="wb.ctWst">CT Worst</th>
              <th data-i18n="wb.ctPot">CT Potential</th>

              <th data-i18n="wb.ctCurOee">CT@OEE (Cur)</th>

              <th data-i18n="wb.cap100">Cap 100% (Cur)</th>
              <th data-i18n="wb.capOee">Cap@OEE (Cur)</th>

              <th data-i18n="wb.vsContract">% vs contract</th>
              <th data-i18n="wb.inputReq">Input req. for Contract</th>

              <th data-i18n="wb.actions">Actions</th>
            </tr>
          </thead>
          <tbody id="wbBody"></tbody>
        </table>
      </div>

      <div class="wb-alert">
        <span class="wb-badge-title" data-i18n="wb.constraintTitle">Constraint / Next:</span>
        <span class="badge badge-bad" id="wbConstraint">—</span>
        <span class="badge badge-warn" id="wbNextConstraint">—</span>
      </div>
      <div class="wb-mini" id="wbConstraintNote"></div>

      <div class="subsection-title" data-i18n="section.statsDetail">Statistical Detail (per process)</div>
      <div style="max-height:260px;overflow:auto;">
        <table id="statsTable">
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.n">N</th>
              <th>Mean</th>
              <th>Median</th>
              <th>P10</th>
              <th>P90</th>
              <th>Min</th>
              <th>Max</th>
              <th>Std</th>
              <th>CV%</th>
              <th>Cp</th>
              <th>Cpk</th>
            </tr>
          </thead>
          <tbody id="statsBody"></tbody>
        </table>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.charts">Charts (selected process)</div>

      <div style="margin-bottom:6px;font-size:.75rem;">
        <label for="chartProcessSelect" data-i18n="label.chartProcessLabel">Process / Mode:</label>
        <select id="chartProcessSelect"></select>
      </div>

      <div class="charts-wrapper">
        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.timeSeriesTitle">Time Series with Mean, Median, ±3σ</div>
          <canvas id="timeSeriesCanvas"></canvas>
        </div>

        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.histTitle">Histogram with Median &amp; Percentiles</div>
          <canvas id="histCanvas"></canvas>
        </div>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.rawData">Raw Time Data</div>
      <div style="max-height:320px;overflow:auto;">
        <table id="dataTable">
          <thead>
            <tr>
              <th data-i18n="col.index">#</th>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.status">Status</th>
              <th data-i18n="col.note">Note</th>
              <th data-i18n="col.t1">T1 (s)</th>
              <th data-i18n="col.t2">T2 (s)</th>
              <th data-i18n="col.total">Total (s)</th>
              <th data-i18n="col.edit">Edit</th>
              <th data-i18n="col.del">Del</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>

    <!-- ✅ Method & Guide AL FINAL, en desplegable, después de Raw Time Data -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.methodGuide">Method &amp; Guide</div>
      <details style="background:var(--bg-card-soft);border:1px solid var(--border-soft);border-radius:14px;padding:10px;">
        <summary style="cursor:pointer;color:var(--text-soft);font-weight:700;">
          <span data-i18n="method.open">Open</span>
        </summary>
        <div style="margin-top:8px;font-size:.72rem;color:var(--text-soft);line-height:1.35;white-space:pre-wrap;" id="methodGuideText"></div>
      </details>
    </div>

  </div>

  <div class="footer-note" data-i18n="footer.note">
    Created by Roberto González – Contact: hzaelglez@gmail.com
  </div>
</div>

<script>
(function(){
  const display = document.getElementById('display');
  const btnStart = document.getElementById('btnStart');
  const btnLap = document.getElementById('btnLap');
  const timerCard = document.getElementById('timerCard');
  const logoGear = document.getElementById('logoGear');

  const sampleInfoTop = document.getElementById('sampleInfoTop');

  const sampleInfoFocus = document.getElementById('sampleInfoFocus');
  const stdInfoFocus = document.getElementById('stdInfoFocus');
  const distInfoFocus = document.getElementById('distInfoFocus');
  const contractInfoFocus = document.getElementById('contractInfoFocus');

  const processInput = document.getElementById('processName');
  const modeSelect   = document.getElementById('mode');
  const effInput     = document.getElementById('efficiency');
  const pcdInput     = document.getElementById('contractPcd');
  const hInput       = document.getElementById('hoursPerDay');
  const dInput       = document.getElementById('daysPerWeek');
  const capViewSel   = document.getElementById('capView');

  const focusBody     = document.getElementById('focusBody');
  const statsBody     = document.getElementById('statsBody');

  const dataBody    = document.getElementById('dataBody');
  const btnCopyAll  = document.getElementById('btnCopyAll');
  const btnCopySum  = document.getElementById('btnCopySummary');
  const btnAddMan   = document.getElementById('btnAddManualLap');
  const btnReset    = document.getElementById('btnReset');

  const chartSelect      = document.getElementById('chartProcessSelect');
  const timeSeriesCanvas = document.getElementById('timeSeriesCanvas');
  const histCanvas       = document.getElementById('histCanvas');

  const langButtons = document.querySelectorAll('.lang-btn');

  // WB
  const wbBody = document.getElementById('wbBody');
  const btnWbAdd = document.getElementById('btnWbAdd');
  const btnWbClear = document.getElementById('btnWbClear');
  const wbConstraint = document.getElementById('wbConstraint');
  const wbNextConstraint = document.getElementById('wbNextConstraint');
  const wbConstraintNote = document.getElementById('wbConstraintNote');
  const methodGuideText = document.getElementById('methodGuideText');
  /* ===== i18n ===== */
  const i18n = {
    en:{
      'title.subtitle':'Cycle Time & Capacity Analyzer',
      'btn.start':'Start','btn.pause':'Pause','btn.lap':'LAP',
      'btn.copyAll':'Copy All','btn.copySummary':'Copy Summary','btn.addManualLap':'Add Manual Lap','btn.reset':'Reset',
      'section.measurementSetup':'Measurement Setup',
      'section.statsFocus':'Stat Focus',
      'section.dataControls':'Data Controls',
      'section.rawData':'Raw Time Data',
      'section.charts':'Charts (selected process)',
      'section.statsDetail':'Statistical Detail (per process)',
      'section.wbPlanner':'WB – Capacity Planner (by process)',
      'section.methodGuide':'Method & Guide',
      'method.open':'Open',

      'label.process':'Process','label.processPlaceholder':'e.g. Op 30-1',
      'label.mode':'Mode','label.efficiency':'Efficiency %','label.contractPcd':'Contract Cap (pcs/day)',
      'label.hoursPerDay':'Hours / Day','label.daysPerWeek':'Days / Week','label.capView':'Capacity View',
      'label.chartProcessLabel':'Process / Mode:',

      'mode.ct':'Cycle Time (CT)','mode.mld':'Machine & Load/Unload',
      'capView.hour':'per Hour','capView.day':'per Day','capView.week':'per Week',

      'col.index':'#','col.process':'Process','col.mode':'Mode','col.status':'Status','col.note':'Note',
      'col.t1':'T1 (s)','col.t2':'T2 (s)','col.total':'Total (s)','col.edit':'Edit','col.del':'Del','col.n':'N',
      'col.sample':'Sample size / Error',
      'col.capCurrent':'Current @Eff','col.capPotential':'Potential @Eff','col.capWorst':'Worst @Eff',
      'col.contract':'Contract','col.gap':'Gap','col.vsContract':'% vs',
      'col.note':'Note',

      'chart.timeSeriesTitle':'Time Series with Mean, Median, ±3σ',
      'chart.histTitle':'Histogram with Median & Percentiles',

      'stats.note':'Simple language on purpose: few / enough samples, low / high variation, capable / not capable.',
      'footer.note':'Created by Roberto González – Contact: hzaelglez@gmail.com',

      // WB text
      'btn.wbAdd':'+ Add Operation',
      'btn.wbClear':'Clear WB',
      'wb.seq':'Seq',
      'wb.enabled':'On',
      'wb.operation':'Operation',
      'wb.operators':'Operators',
      'wb.shifts':'Shifts',
      'wb.hours':'Hours',
      'wb.machines':'# Machines',
      'wb.contract':'Contract (pcs/day)',
      'wb.gross':'Gross min/day',
      'wb.lunch':'Lunch min/day',
      'wb.changeover':'Changeover (min/day)',
      'wb.cleaning':'5S/Clean (min/day)',
      'wb.maint':'Maintenance (min/day)',
      'wb.other':'Other (min/day)',
      'wb.udt':'Unplanned DT',
      'wb.udtUnit':'Unit',
      'wb.net':'Net min/day',
      'wb.scrap':'Scrap %',
      'wb.yield':'Yield',
      'wb.oeeA':'A%',
      'wb.oeeP':'P%',
      'wb.oeeQ':'Q%',
      'wb.oee':'OEE%',
      'wb.ctCur':'CT Current (s)',
      'wb.ctWst':'CT Worst (s)',
      'wb.ctPot':'CT Potential (s)',
      'wb.ctCurOee':'CT@OEE (Cur)',
      'wb.cap100':'Cap 100% (Cur/day)',
      'wb.capOee':'Cap@OEE (Cur/day)',
      'wb.vsContract':'% vs contract',
      'wb.inputReq':'Input req. for Contract',
      'wb.actions':'Actions',
      'wb.constraintTitle':'Constraint / Next:'
    },
    es:{
      'title.subtitle':'Analizador de Tiempo de Ciclo y Capacidad',
      'btn.start':'Iniciar','btn.pause':'Pausar','btn.lap':'VUELTA',
      'btn.copyAll':'Copiar todo','btn.copySummary':'Copiar resumen','btn.addManualLap':'Agregar vuelta manual','btn.reset':'Reiniciar',
      'section.measurementSetup':'Configuración de Medición',
      'section.statsFocus':'Enfoque Estadístico',
      'section.dataControls':'Controles de Datos',
      'section.rawData':'Datos Crudos de Tiempo',
      'section.charts':'Gráficas (proceso seleccionado)',
      'section.statsDetail':'Detalle Estadístico (por proceso)',
      'section.wbPlanner':'WB – Planeador de Capacidad (por proceso)',
      'section.methodGuide':'Método & Guía',
      'method.open':'Abrir',

      'label.process':'Proceso','label.processPlaceholder':'p. ej. Op 30-1',
      'label.mode':'Modo','label.efficiency':'Eficiencia %','label.contractPcd':'Capacidad contrato (pzs/día)',
      'label.hoursPerDay':'Horas / día','label.daysPerWeek':'Días / semana','label.capView':'Vista de capacidad',
      'label.chartProcessLabel':'Proceso / Modo:',

      'mode.ct':'Tiempo de ciclo (CT)','mode.mld':'Máquina y Carga/Descarga',
      'capView.hour':'por hora','capView.day':'por día','capView.week':'por semana',

      'col.index':'#','col.process':'Proceso','col.mode':'Modo','col.status':'Estatus','col.note':'Nota',
      'col.t1':'T1 (s)','col.t2':'T2 (s)','col.total':'Total (s)','col.edit':'Editar','col.del':'Borrar','col.n':'N',
      'col.sample':'Tamaño de muestra / Error',
      'col.capCurrent':'Actual @Eff','col.capPotential':'Potencial @Eff','col.capWorst':'Peor @Eff',
      'col.contract':'Contrato','col.gap':'Gap','col.vsContract':'% vs',
      'col.note':'Nota',

      'chart.timeSeriesTitle':'Serie de tiempo con media, mediana y ±3σ',
      'chart.histTitle':'Histograma con mediana y percentiles',

      'stats.note':'Lenguaje simple: pocas / suficientes muestras, baja / alta variación, capaz / no capaz.',
      'footer.note':'Creado por Roberto González – Contacto: hzaelglez@gmail.com',

      // WB
      'btn.wbAdd':'+ Agregar operación',
      'btn.wbClear':'Borrar WB',
      'wb.seq':'Orden',
      'wb.enabled':'On',
      'wb.operation':'Operación',
      'wb.operators':'Operadores',
      'wb.shifts':'Turnos',
      'wb.hours':'Horas',
      'wb.machines':'# Máquinas',
      'wb.contract':'Contrato (pzs/día)',
      'wb.gross':'Min brutos/día',
      'wb.lunch':'Comida/día',
      'wb.changeover':'Changeover (min/día)',
      'wb.cleaning':'5S/Limpieza (min/día)',
      'wb.maint':'Mtto (min/día)',
      'wb.other':'Otros (min/día)',
      'wb.udt':'DT no planeado',
      'wb.udtUnit':'Unidad',
      'wb.net':'Min netos/día',
      'wb.scrap':'Scrap %',
      'wb.yield':'Yield',
      'wb.oeeA':'Disp%',
      'wb.oeeP':'Rend%',
      'wb.oeeQ':'Calidad%',
      'wb.oee':'OEE%',
      'wb.ctCur':'CT Actual (s)',
      'wb.ctWst':'CT Peor (s)',
      'wb.ctPot':'CT Potencial (s)',
      'wb.ctCurOee':'CT@OEE (Act)',
      'wb.cap100':'Cap 100% (Act/día)',
      'wb.capOee':'Cap@OEE (Act/día)',
      'wb.vsContract':'% vs contrato',
      'wb.inputReq':'Entrada req. p/Contrato',
      'wb.actions':'Acciones',
      'wb.constraintTitle':'Restricción / Siguiente:'
    }
  };

  let currentLang = localStorage.getItem('taktlabLang') || 'en';

  function t(key){
    return (i18n[currentLang] && i18n[currentLang][key]) || i18n.en[key] || key;
  }

  function applyTranslations(){
    document.querySelectorAll('[data-i18n]').forEach(el=>{
      const key = el.dataset.i18n;
      if(el === btnStart) return;
      el.textContent = t(key);
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el=>{
      const key = el.dataset.i18nPlaceholder;
      el.placeholder = t(key);
    });
  }
  function updateLangButtons(){
    langButtons.forEach(b=>b.classList.toggle('active', b.dataset.lang === currentLang));
  }
  function setLanguage(lang){
    currentLang = (lang==='es') ? 'es' : 'en';
    localStorage.setItem('taktlabLang', currentLang);
    document.documentElement.lang = currentLang;
    updateLangButtons();
    applyTranslations();
    btnStart.textContent = running ? t('btn.pause') : t('btn.start');
    renderAll();
  }
  langButtons.forEach(btn=>btn.addEventListener('click',()=>setLanguage(btn.dataset.lang)));

  let running=false, startTime=0, elapsed=0, timerId=null;
  let laps=[], nextId=1;
  let pendingT1=null;

  // ===== WB model (persist) =====
  const WB_KEY = 'taktlabWB_v1';
  function defaultWbRow(){
    return {
      id: 'wb_' + Math.random().toString(36).slice(2,9),
      seq: 10,
      enabled: true,
      operation: '',
      operators: 1,
      shifts: 1,
      hours: 8,
      machines: 1,
      contractPcd: 0,
      changeoverMin: 0,
      cleanMin: 0,
      maintMin: 0,
      otherMin: 0,
      udtValue: 0,
      udtUnit: 'min_day', // 'min_day' | 'sec_hour'
      scrapPct: 0,
      oeeA: 100,
      oeeP: 100,
      oeeQ: 100,
      // Manual overrides if no study exists
      ctCurManual: null,
      ctWstManual: null,
      ctPotManual: null
    };
  }
  let wbRows = [];

  function loadWB(){
    try{
      const raw = localStorage.getItem(WB_KEY);
      if(!raw){ wbRows=[]; return; }
      const parsed = JSON.parse(raw);
      if(Array.isArray(parsed)) wbRows = parsed;
      else wbRows=[];
    }catch(e){ wbRows=[]; }
  }
  function saveWB(){
    try{ localStorage.setItem(WB_KEY, JSON.stringify(wbRows)); }catch(e){}
  }

  function pad2(n){return n<10?'0'+n:''+n;}
  function formatTime(ms){
    const total=Math.max(ms,0);
    const mins=Math.floor(total/60000);
    const secs=Math.floor((total%60000)/1000);
    const cent=Math.floor((total%1000)/10);
    return pad2(mins)+':'+pad2(secs)+'.'+pad2(cent);
  }
  function formatSecs(s){
    if(!isFinite(s)) return '-';
    return (Math.round(s*10)/10).toFixed(1);
  }
  function formatUnits(n){
    if(!isFinite(n)) return '-';
    const rounded=Math.round(n);
    return rounded.toLocaleString('en-US',{maximumFractionDigits:0});
  }
  function clamp(n,min,max){
    n = isFinite(n)?n:0;
    return Math.min(Math.max(n,min),max);
  }
  function pct(n, digits=0){
    if(!isFinite(n)) return '-';
    return n.toFixed(digits)+'%';
  }

  function updateDisplay(){ display.textContent = formatTime(elapsed); }
  function refreshRingStates(){
    if(!running){ logoGear.classList.remove('spinning'); return; }
    logoGear.classList.add('spinning');
  }

  function tick(){
    const now=performance.now();
    elapsed=now-startTime;
    updateDisplay();
    timerId=requestAnimationFrame(tick);
  }
  function start(){
    if(running) return;
    running=true;
    startTime=performance.now()-elapsed;
    timerId=requestAnimationFrame(tick);
    btnStart.textContent=t('btn.pause');
    refreshRingStates();
  }
  function pause(){
    if(!running) return;
    running=false;
    cancelAnimationFrame(timerId);
    timerId=null;
    btnStart.textContent=t('btn.start');
    refreshRingStates();
  }
  btnStart.addEventListener('click',()=>{ running?pause():start(); });

  function flashCard(){
    timerCard.classList.add('flash');
    setTimeout(()=>timerCard.classList.remove('flash'),120);
  }

  function vibrate(ms=18){
    try{
      if(navigator.vibrate) navigator.vibrate(ms);
    }catch(e){}
  }

  function ensureDefaults(){
    let proc=(processInput.value||'').trim();
    if(!proc){
      proc = currentLang==='es' ? 'Proceso 1' : 'Process 1';
      processInput.value=proc;
    }
    let mode=modeSelect.value||'CT';
    modeSelect.value=mode;
    return {proc,mode};
  }

  // ✅ Auto-crear/actualizar WB row desde lo que estás midiendo (proceso/estación)
  // - Hours toma Hours/Day
  // - Contract toma Contract (pcs/day)
  // - Yield toma Efficiency% (mapeado a Q% por default)
  function ensureWbRowForOperation(opName){
    const op = (opName||'').trim();
    if(!op) return;

    let row = wbRows.find(r => (r.operation||'').trim() === op);
    if(!row){
      row = defaultWbRow();
      const maxSeq = wbRows.reduce((m,x)=>Math.max(m, parseFloat(x.seq)||0), 0);
      row.seq = (maxSeq||0) + 10;
      row.operation = op;
      wbRows.push(row);
    }

    const globalHours = clamp(parseFloat(hInput.value)||8, 1, 24);
    const globalContract = Math.max(0, parseFloat(pcdInput.value)||0);
    const globalYieldPct = clamp(parseFloat(effInput.value)||100, 0, 100);

    if(!isFinite(parseFloat(row.hours)) || parseFloat(row.hours) <= 0) row.hours = globalHours;
    if(!isFinite(parseFloat(row.contractPcd)) || parseFloat(row.contractPcd) <= 0) row.contractPcd = globalContract;

    // Si Q está en default (100) o vacío, lo jalamos de Efficiency% (Yield)
    if(!isFinite(parseFloat(row.oeeQ)) || parseFloat(row.oeeQ) <= 0 || parseFloat(row.oeeQ) === 100){
      row.oeeQ = globalYieldPct;
    }

    saveWB();
  }

  function addLap(manualData){
    const {proc,mode}=ensureDefaults();

    // ✅ Siempre amarramos WB a la estación/proceso que estás midiendo
    ensureWbRowForOperation(proc);

    const status='', note='';
    if(manualData){
      const {t1,t2,total}=manualData;
      laps.push({id:nextId++,process:proc,mode,status,note,t1,t2,total});
      renderAll();
      return;
    }
    const seconds=Math.max(elapsed/1000,0);
    if(mode==='CT'){
      laps.push({id:nextId++,process:proc,mode,status,note,t1:seconds,t2:0,total:seconds});
      elapsed=0; startTime=performance.now();
      updateDisplay(); pendingT1=null;
      renderAll();
      return;
    }
    if(pendingT1===null){
      pendingT1=seconds;
      elapsed=0; startTime=performance.now();
    }else{
      const t2=seconds, t1=pendingT1;
      laps.push({id:nextId++,process:proc,mode,status,note,t1,t2,total:t1+t2});
      pendingT1=null;
      elapsed=0; startTime=performance.now();
      updateDisplay();
      renderAll();
    }
  }

  btnLap.addEventListener('click',()=>{
    flashCard();
    vibrate(18);
    addLap();
  });

  btnAddMan.addEventListener('click',()=>{
    const t1 = parseFloat(prompt(currentLang==='es'?'T1 (s)':'T1 (s)',''));
    const t2 = parseFloat(prompt(currentLang==='es'?'T2 (s)':'T2 (s)',''));
    if(isNaN(t1) && isNaN(t2)) return;
    const v1=isNaN(t1)?0:t1, v2=isNaN(t2)?0:t2;
    addLap({t1:v1,t2:v2,total:v1+v2});
  });

  btnReset.addEventListener('click',()=>{
    pause();
    elapsed=0; updateDisplay();
    laps=[]; nextId=1; pendingT1=null;
    renderAll();
  });

  modeSelect.addEventListener('change',()=>{ pendingT1=null; });

  function groupByProcess(){
    const map=new Map();
    laps.forEach(l=>{
      const key=l.process+'||'+l.mode;
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push(l);
    });
    return map;
  }

  function percentile(values,p){
    const n=values.length;
    if(n===0) return NaN;
    if(n===1) return values[0];
    const idx=(n-1)*p;
    const lo=Math.floor(idx), hi=Math.ceil(idx);
    if(lo===hi) return values[lo];
    return values[lo]+(values[hi]-values[lo])*(idx-lo);
  }

  function calcStats(arr){
    if(!arr.length) return null;
    const values=arr.map(x=>x.total).slice().sort((a,b)=>a-b);
    const n=values.length;
    const mean=values.reduce((s,v)=>s+v,0)/n;
    const median=n%2?values[(n-1)/2]:(values[n/2-1]+values[n/2])/2;
    const min=values[0], max=values[n-1];
    const variance=values.reduce((s,v)=>s+Math.pow(v-mean,2),0)/(n-1||1);
    const std=Math.sqrt(variance);
    const p10=percentile(values,0.1);
    const p90=percentile(values,0.9);
    const cv=mean?std/mean:0;
    return {n,values,mean,median,min,max,std,p10,p90,cv};
  }

  function computeCtTargetSeconds(){
    const pcd=parseFloat(pcdInput.value)||0;
    const hours=Math.min(Math.max(parseFloat(hInput.value)||8,1),24);
    if(pcd<=0) return null;
    return (hours*3600)/pcd;
  }

  function capFromCt(ctSeconds, view, hours, days){
    if(!ctSeconds || ctSeconds<=0) return 0;
    const perHour=3600/ctSeconds;
    if(view==='hour') return perHour;
    if(view==='day') return perHour*hours;
    return perHour*hours*days;
  }
  function contractUnitsFromPcd(pcd, view, hours, days){
    if(!pcd || pcd<=0) return 0;
    if(view==='hour') return (pcd/hours)||0;
    if(view==='day') return pcd;
    return pcd*days;
  }

  /* ===== Método único confirmado para muestras ===== */
  function sampleReqN(cv){
    const Z=1.96, targetError=0.03;
    if(!isFinite(cv) || cv<=0) return 10;
    let n = Math.ceil(Math.pow((Z*cv)/targetError,2));
    if(n<10) n=10;
    return n;
  }
  function estErrorPct(cv,n){
    const Z=1.96;
    if(!isFinite(cv) || cv<=0 || n<=0) return 0;
    return (Z*cv)/Math.sqrt(n)*100;
  }

  function setInfo(div, cls, text){
    div.className = 'info-line ' + cls;
    div.textContent = text;
  }

  function buildSampleLine(st){
    if(!st || st.n<3){
      return {
        cls:'sample-neutral',
        text:(currentLang==='es'
          ? `Tamaño de muestra: ${st?st.n:0} / 3 – se requieren ≥3 vueltas antes de estimar el error.`
          : `Sample size: ${st?st.n:0} / 3 – need ≥3 laps before estimating error.`
        )
      };
    }
    const n=st.n;
    const cv=st.cv||0;
    const recN = sampleReqN(cv);
    const errPct = estErrorPct(cv,n);
    const ratio=n/recN;

    let cls='sample-warn', tail='';
    if(ratio<0.6){
      cls='sample-bad';
      tail = currentLang==='es'
        ? 'Muestra muy pequeña para ±3% – úsala solo como referencia.'
        : 'Sample too small for ±3% – use only as reference.';
    }else if(ratio<0.9){
      cls='sample-warn';
      tail = currentLang==='es'
        ? 'Casi suficiente para ±3% – un par de vueltas más ayudarán.'
        : 'Almost enough for ±3% – a couple more laps would help.';
    }else{
      cls='sample-good';
      tail = currentLang==='es'
        ? 'Tamaño de muestra suficiente para objetivo ±3%.'
        : 'Sample size is enough for ±3% target.';
    }

    const head = (currentLang==='es')
      ? `Tamaño de muestra: ${n} / ${recN} · Error estimado: ±${errPct.toFixed(1)}% (95%) – `
      : `Sample size: ${n} / ${recN} · Est. error: ±${errPct.toFixed(1)}% (95%) – `;

    return {cls, text: head + tail};
  }
  function updateSemaphores(){
    const groups=groupByProcess();
    const {proc,mode}=ensureDefaults();
    const key=proc+'||'+mode;
    const arr=groups.get(key)||[];

    if(!arr.length){
      const topMsg = currentLang==='es'
        ? 'Aún no hay muestras para el proceso actual. Comienza a tomar vueltas.'
        : 'No samples yet for current process. Start capturing laps.';
      setInfo(sampleInfoTop,'sample-neutral', topMsg);

      setInfo(sampleInfoFocus,'sample-neutral', topMsg);
      setInfo(stdInfoFocus,'sample-neutral', currentLang==='es' ? 'Std dev: — (—). Captura más vueltas.' : 'Std dev: — (—). Capture more laps.');
      setInfo(distInfoFocus,'sample-neutral', currentLang==='es' ? 'Media vs Mediana: —. Captura más vueltas.' : 'Mean vs Median: —. Capture more laps.');
      setInfo(contractInfoFocus,'sample-neutral', currentLang==='es'
        ? 'Sin contrato cargado – no se evalúa capacidad vs objetivo.'
        : 'No contract loaded – capacity vs target not evaluated.'
      );
      return;
    }

    const st=calcStats(arr);

    const sampleLine = buildSampleLine(st);
    setInfo(sampleInfoTop, sampleLine.cls, sampleLine.text);
    setInfo(sampleInfoFocus, sampleLine.cls, sampleLine.text);

    if(!st || st.n<3 || !isFinite(st.std)){
      setInfo(stdInfoFocus,'sample-neutral',
        currentLang==='es' ? 'Std dev: — (—). Captura más vueltas.' : 'Std dev: — (—). Capture more laps.'
      );
    } else {
      const cvPct = st.cv*100;
      let cls = 'sample-good';
      let label = currentLang==='es' ? 'Variación baja.' : 'Low variation.';
      if(cvPct>=10 && cvPct<20){ cls='sample-warn'; label = currentLang==='es'?'Variación moderada.':'Moderate variation.'; }
      if(cvPct>=20){ cls='sample-bad'; label = currentLang==='es'?'Variación alta: proceso “nervioso”.':'High variation: process is “nervy”.'; }

      setInfo(stdInfoFocus, cls,
        (currentLang==='es'
          ? `Std dev ≈ ${formatSecs(st.std)} s (${cvPct.toFixed(1)}%). ${label}`
          : `Std dev ≈ ${formatSecs(st.std)} s (${cvPct.toFixed(1)}%). ${label}`
        )
      );
    }

    if(!st || st.n<3 || !isFinite(st.mean) || !isFinite(st.median) || st.mean===0){
      setInfo(distInfoFocus,'sample-neutral',
        currentLang==='es' ? 'Media vs Mediana: —. Captura más vueltas.' : 'Mean vs Median: —. Capture more laps.'
      );
    } else {
      const diff = Math.abs(st.mean - st.median) / st.mean * 100;
      let cls='sample-good';
      let msg = currentLang==='es'
        ? 'Media y mediana cercanas – distribución cercana a normal.'
        : 'Mean and median are close – distribution near normal.';
      if(diff>=5 && diff<10){
        cls='sample-warn';
        msg = currentLang==='es'
          ? 'Media y mediana algo separadas – posible sesgo.'
          : 'Mean and median somewhat apart – possible skew.';
      }
      if(diff>=10){
        cls='sample-bad';
        msg = currentLang==='es'
          ? 'Media y mediana muy separadas – hay cola/sesgo fuerte.'
          : 'Mean and median far apart – strong skew/tail.';
      }

      setInfo(distInfoFocus, cls,
        (currentLang==='es'
          ? `Media ≈ ${formatSecs(st.mean)} s, Mediana ≈ ${formatSecs(st.median)} s. ${msg}`
          : `Mean ≈ ${formatSecs(st.mean)} s, Median ≈ ${formatSecs(st.median)} s. ${msg}`
        )
      );
    }

    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseInt(dInput.value)||5,1,7);
    const pcd=Math.max(0, parseFloat(pcdInput.value)||0);
    const view=capViewSel.value;

    const contractUnits = contractUnitsFromPcd(pcd,view,hours,days);
    if(!contractUnits || contractUnits<=0 || !st || st.n<1){
      setInfo(contractInfoFocus,'sample-neutral',
        currentLang==='es'
          ? 'Sin contrato cargado – no se evalúa capacidad vs objetivo.'
          : 'No contract loaded – capacity vs target not evaluated.'
      );
    } else {
      const capCur = capFromCt(st.median,view,hours,days)*(eff/100);
      const pctVs = (capCur/contractUnits*100);
      let cls='sample-bad';
      let msg = currentLang==='es' ? 'No alcanza.' : 'Below target.';
      if(pctVs>=85 && pctVs<100){ cls='sample-warn'; msg = currentLang==='es' ? 'Muy justo.' : 'Tight.'; }
      if(pctVs>=100){ cls='sample-good'; msg = currentLang==='es' ? 'Cumple contrato.' : 'Meets contract.'; }

      setInfo(contractInfoFocus, cls,
        (currentLang==='es'
          ? `Capacidad actual @${eff}%: ${formatUnits(capCur)} vs Contrato: ${formatUnits(contractUnits)} · ${pctVs.toFixed(0)}% – ${msg}`
          : `Current capacity @${eff}%: ${formatUnits(capCur)} vs Contract: ${formatUnits(contractUnits)} · ${pctVs.toFixed(0)}% – ${msg}`
        )
      );
    }
  }

  function renderDataTable(){
    dataBody.innerHTML='';
    const statusOptions = currentLang==='es'
      ? ['','Falta material','Bloqueado','Mtto']
      : ['','Starved','Blocked','DT Maint'];

    laps.forEach((lap,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${i+1}</td>
        <td>${lap.process}</td>
        <td>${lap.mode}</td>
        <td>
          <select class="status-select" data-id="${lap.id}" style="background:#020b1a;border:1px solid var(--border-soft);border-radius:8px;color:var(--text-soft);font-size:.72rem;">
            ${statusOptions.map(opt=>`<option value="${opt}" ${opt===lap.status?'selected':''}>${opt}</option>`).join('')}
          </select>
        </td>
        <td>
          <input type="text" class="note-input" data-id="${lap.id}" value="${lap.note||''}"
            style="width:120px;background:#020b1a;border-radius:6px;border:1px solid var(--border-soft);color:var(--text-soft);font-size:.72rem;padding:2px 4px;">
        </td>
        <td>${formatSecs(lap.t1)}</td>
        <td>${formatSecs(lap.t2)}</td>
        <td>${formatSecs(lap.total)}</td>
        <td><button class="btn-edit" data-id="${lap.id}">${currentLang==='es'?'Editar':'Edit'}</button></td>
        <td><button class="btn-del" data-id="${lap.id}">X</button></td>
      `;
      dataBody.appendChild(tr);
    });

    dataBody.querySelectorAll('.btn-del').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=parseInt(btn.dataset.id,10);
        laps=laps.filter(l=>l.id!==id);
        renderAll();
      });
    });

    dataBody.querySelectorAll('.btn-edit').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=parseInt(btn.dataset.id,10);
        const lap=laps.find(l=>l.id===id);
        if(!lap) return;
        const t1=parseFloat(prompt(currentLang==='es'?'Editar T1 (s)':'Edit T1 (s)', lap.t1.toFixed(2)));
        const t2=parseFloat(prompt(currentLang==='es'?'Editar T2 (s)':'Edit T2 (s)', lap.t2.toFixed(2)));
        if(isNaN(t1) && isNaN(t2)) return;
        if(!isNaN(t1)) lap.t1=t1;
        if(!isNaN(t2)) lap.t2=t2;
        lap.total=lap.t1+lap.t2;
        renderAll();
      });
    });

    dataBody.querySelectorAll('.status-select').forEach(sel=>{
      sel.addEventListener('change',()=>{
        const id=parseInt(sel.dataset.id,10);
        const lap=laps.find(l=>l.id===id);
        if(lap) lap.status=sel.value;
      });
    });

    dataBody.querySelectorAll('.note-input').forEach(inp=>{
      inp.addEventListener('change',()=>{
        const id=parseInt(inp.dataset.id,10);
        const lap=laps.find(l=>l.id===id);
        if(lap) lap.note=inp.value;
      });
    });
  }

  function renderStatsDetail(){
    statsBody.innerHTML='';
    const groups=groupByProcess();
    const ctTarget=computeCtTargetSeconds();

    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;

      let cp='-', cpk='-';
      if(ctTarget && st.std>0){
        const USL=ctTarget, LSL=0;
        const cpv=(USL-LSL)/(6*st.std);
        const cpu=(USL-st.mean)/(3*st.std);
        const cpl=(st.mean-LSL)/(3*st.std);
        const cpkv=Math.min(cpu,cpl);
        cp=cpv.toFixed(2);
        cpk=cpkv.toFixed(2);
      }

      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${st.n}</td>
        <td>${formatSecs(st.mean)}</td>
        <td>${formatSecs(st.median)}</td>
        <td>${formatSecs(st.p10)}</td>
        <td>${formatSecs(st.p90)}</td>
        <td>${formatSecs(st.min)}</td>
        <td>${formatSecs(st.max)}</td>
        <td>${formatSecs(st.std)}</td>
        <td>${(st.cv*100).toFixed(1)}</td>
        <td>${cp}</td>
        <td>${cpk}</td>
      `;
      statsBody.appendChild(tr);
    });
  }

  function renderFocusTable(){
    focusBody.innerHTML='';
    const groups=groupByProcess();

    if(!groups.size){
      const tr=document.createElement('tr');
      tr.innerHTML = `<td colspan="18" style="text-align:left;color:var(--text-muted);">
        ${currentLang==='es'
          ? 'Sin muestras aún. Toma vueltas y aquí se llenará la tabla con conceptos.'
          : 'No samples yet. Take laps and this table will populate with concepts.'}
      </td>`;
      focusBody.appendChild(tr);
      return;
    }

    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseInt(dInput.value)||5,1,7);
    const pcd=Math.max(0, parseFloat(pcdInput.value)||0);
    const view=capViewSel.value;

    const ctTarget=computeCtTargetSeconds();
    const contractUnits = contractUnitsFromPcd(pcd,view,hours,days);

    const keys=[...groups.keys()].sort((a,b)=>a.localeCompare(b));

    keys.forEach(key=>{
      const arr=groups.get(key);
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;

      const recN = sampleReqN(st.cv);
      const errPct = estErrorPct(st.cv, st.n);

      const capCur = capFromCt(st.median,view,hours,days)*(eff/100);
      const capPot = capFromCt(st.p10,view,hours,days)*(eff/100);
      const capWst = capFromCt(st.p90,view,hours,days)*(eff/100);

      const gap = (contractUnits>0) ? (capCur - contractUnits) : NaN;
      const pctVs = (contractUnits>0) ? (capCur/contractUnits*100) : NaN;

      let badgeClass='';
      if(isFinite(pctVs)){
        if(pctVs<85) badgeClass='badge-bad';
        else if(pctVs<100) badgeClass='badge-warn';
        else badgeClass='badge-good';
      }

      let cp='-', cpk='-';
      if(ctTarget && st.std>0){
        const USL=ctTarget, LSL=0;
        const cpv=(USL-LSL)/(6*st.std);
        const cpu=(USL-st.mean)/(3*st.std);
        const cpl=(st.mean-LSL)/(3*st.std);
        const cpkv=Math.min(cpu,cpl);
        cp=cpv.toFixed(2);
        cpk=cpkv.toFixed(2);
      }

      let note='';
      const ratio=st.n/recN;
      if(ratio<0.6) note = currentLang==='es' ? 'Muestra chica: no te cases.' : 'Tiny sample: don’t marry it.';
      else if(st.cv>0.20) note = currentLang==='es' ? 'Alta variación: hay fantasmas.' : 'High variation: ghosts here.';
      else if(isFinite(pctVs) && pctVs<100) note = currentLang==='es' ? 'No alcanza contrato.' : 'Below contract.';
      else note = currentLang==='es' ? 'Se ve sano.' : 'Looks healthy.';

      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${st.n}</td>
        <td style="text-align:left">
          ${currentLang==='es'
            ? `Tamaño de muestra: ${st.n} / ${recN} · Error estimado: ±${errPct.toFixed(1)}% (95%)`
            : `Sample size: ${st.n} / ${recN} · Est. error: ±${errPct.toFixed(1)}% (95%)`
          }
        </td>
        <td>${formatSecs(st.std)}</td>
        <td>${(st.cv*100).toFixed(1)}</td>
        <td>${formatSecs(st.median)}</td>
        <td>${formatSecs(st.p10)}</td>
        <td>${formatSecs(st.p90)}</td>
        <td>${capCur?formatUnits(capCur):'-'}</td>
        <td>${capPot?formatUnits(capPot):'-'}</td>
        <td>${capWst?formatUnits(capWst):'-'}</td>
        <td>${contractUnits>0?formatUnits(contractUnits):'-'}</td>
        <td>${isFinite(gap)?((gap>=0?'+':'')+formatUnits(gap)):'-'}</td>
        <td>${isFinite(pctVs)?`<span class="badge ${badgeClass}">${pctVs.toFixed(0)}%</span>`:'-'}</td>
        <td>${cp}</td>
        <td>${cpk}</td>
        <td style="text-align:left;color:var(--text-soft)">${note}</td>
      `;
      focusBody.appendChild(tr);
    });
  }

  // ===== WB helpers =====
  function lunchMinutesPerShift(hours){
    if(hours<=6) return 15;
    if(hours<=8) return 30;
    if(hours<=10) return 45;
    return 60;
  }

  function getStudyStatsForOperation(opName){
    const groups=groupByProcess();
    let best=null;
    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      if((proc||'').trim() === (opName||'').trim()){
        const st=calcStats(arr);
        if(st && st.n>=1){
          if(!best) best={st,mode};
          else if(best.mode!=='CT' && mode==='CT') best={st,mode};
          else if(st.n>best.st.n) best={st,mode};
        }
      }
    });
    return best;
  }

  // ✅ OEE correcto y capado: 0..1 (0%..100%)
  function computeOeePct(row){
    const a = clamp(parseFloat(row.oeeA),0,100)/100;
    const p = clamp(parseFloat(row.oeeP),0,100)/100;
    const q = clamp(parseFloat(row.oeeQ),0,100)/100;
    return clamp(a*p*q,0,1);
  }

  function computeUdtMinutes(row){
    const shifts = clamp(parseFloat(row.shifts),0,10);
    const hours = clamp(parseFloat(row.hours),0,24);
    const v = clamp(parseFloat(row.udtValue),0,1e9);
    if(row.udtUnit==='sec_hour'){
      const totalSeconds = v * (hours*shifts);
      return totalSeconds/60;
    }
    return v;
  }

  function computeGrossMinutes(row){
    const shifts = clamp(parseFloat(row.shifts),0,10);
    const hours = clamp(parseFloat(row.hours),0,24);
    const machines = clamp(parseFloat(row.machines),0,999);
    return hours*60*shifts*machines;
  }

  function computeLunchMinutes(row){
    const shifts = clamp(parseFloat(row.shifts),0,10);
    const hours = clamp(parseFloat(row.hours),0,24);
    const perShift = lunchMinutesPerShift(hours);
    return perShift*shifts;
  }

  function computeNetMinutes(row){
    const gross = computeGrossMinutes(row);
    const lunch = computeLunchMinutes(row);
    const changeover = clamp(parseFloat(row.changeoverMin),0,1e9);
    const clean = clamp(parseFloat(row.cleanMin),0,1e9);
    const maint = clamp(parseFloat(row.maintMin),0,1e9);
    const other = clamp(parseFloat(row.otherMin),0,1e9);
    const udt = computeUdtMinutes(row);
    const net = gross - lunch - changeover - clean - maint - other - udt;
    return Math.max(0, net);
  }

  function getCtTriple(row){
    const study = getStudyStatsForOperation(row.operation);
    if(study && study.st){
      const st = study.st;
      return {
        cur: st.median,
        wst: st.p90,
        pot: st.p10,
        source: `study (${study.mode}, N=${st.n})`
      };
    }
    const cur = row.ctCurManual!=null ? parseFloat(row.ctCurManual) : NaN;
    const wst = row.ctWstManual!=null ? parseFloat(row.ctWstManual) : NaN;
    const pot = row.ctPotManual!=null ? parseFloat(row.ctPotManual) : NaN;
    return {
      cur: isFinite(cur)?cur:NaN,
      wst: isFinite(wst)?wst:NaN,
      pot: isFinite(pot)?pot:NaN,
      source: 'manual'
    };
  }

  function computeCapacityPerDay(netMinutes, ctSeconds){
    if(!isFinite(netMinutes) || netMinutes<=0) return 0;
    if(!isFinite(ctSeconds) || ctSeconds<=0) return 0;
    const netSeconds = netMinutes*60;
    return netSeconds/ctSeconds;
  }

  function computeScrapYield(row){
    const scrap = clamp(parseFloat(row.scrapPct),0,100)/100;
    return (1 - scrap);
  }

  function renderWB(){
    wbRows.sort((a,b)=>{
      const sa = parseFloat(a.seq)||0;
      const sb = parseFloat(b.seq)||0;
      if(sa!==sb) return sa-sb;
      return (a.operation||'').localeCompare(b.operation||'');
    });

    wbBody.innerHTML='';

    wbRows.forEach((row,idx)=>{
      const gross = computeGrossMinutes(row);
      const lunch = computeLunchMinutes(row);
      const udtMin = computeUdtMinutes(row);
      const net = computeNetMinutes(row);

      const oee = computeOeePct(row);
      const oeePct = oee*100;

      const y = computeScrapYield(row);
      const yPct = y*100;

      const ct = getCtTriple(row);
      const ctCur = ct.cur;
      const ctWst = ct.wst;
      const ctPot = ct.pot;

      const ctCurOee = (isFinite(ctCur) && oee>0) ? (ctCur / oee) : NaN;

      const cap100Cur = computeCapacityPerDay(net, ctCur);
      const capOeeCur = cap100Cur * oee;

      const contract = clamp(parseFloat(row.contractPcd),0,1e12);
      const vs = (contract>0 && capOeeCur>0) ? (capOeeCur/contract*100) : NaN;

      const inputReq = (contract>0 && y>0) ? (contract / y) : NaN;

      const tr=document.createElement('tr');
      const inp = (val, cls='') => `<input class="wb-inp ${cls}" value="${val==null?'':val}">`;

      tr.innerHTML = `
        <td>${inp(row.seq,'slim')}</td>
        <td style="text-align:center"><input type="checkbox" class="wb-chk" ${row.enabled?'checked':''}></td>
        <td>${`<input class="wb-inp wide" value="${row.operation||''}" placeholder="${currentLang==='es'?'p. ej. Op 30-1':'e.g. Op 30-1'}">`}</td>

        <td>${inp(row.operators,'slim')}</td>
        <td>${inp(row.shifts,'slim')}</td>
        <td>${inp(row.hours,'slim')}</td>
        <td>${inp(row.machines,'slim')}</td>
        <td>${inp(row.contractPcd,'')}</td>

        <td>${formatUnits(gross)}</td>
        <td>${formatUnits(lunch)}</td>

        <td>${inp(row.changeoverMin,'slim')}</td>
        <td>${inp(row.cleanMin,'slim')}</td>
        <td>${inp(row.maintMin,'slim')}</td>
        <td>${inp(row.otherMin,'slim')}</td>

        <td>${inp(row.udtValue,'slim')}</td>
        <td>
          <select class="wb-sel">
            <option value="min_day" ${row.udtUnit==='min_day'?'selected':''}>${currentLang==='es'?'min/día':'min/day'}</option>
            <option value="sec_hour" ${row.udtUnit==='sec_hour'?'selected':''}>${currentLang==='es'?'seg/h':'sec/hr'}</option>
          </select>
        </td>

        <td>${formatUnits(net)}</td>

        <td>${inp(row.scrapPct,'slim')}</td>
        <td>${isFinite(yPct)?yPct.toFixed(1)+'%':'-'}</td>

        <td>${inp(row.oeeA,'slim')}</td>
        <td>${inp(row.oeeP,'slim')}</td>
        <td>${inp(row.oeeQ,'slim')}</td>
        <td>${isFinite(oeePct)?oeePct.toFixed(1)+'%':'-'}</td>

        <td title="${ct.source}">${isFinite(ctCur)?formatSecs(ctCur):`<span class="wb-pill">${currentLang==='es'?'captura CT':'enter CT'}</span>`}</td>
        <td title="${ct.source}">${isFinite(ctWst)?formatSecs(ctWst):'-'}</td>
        <td title="${ct.source}">${isFinite(ctPot)?formatSecs(ctPot):'-'}</td>

        <td>${isFinite(ctCurOee)?formatSecs(ctCurOee):'-'}</td>

        <td>${cap100Cur?formatUnits(cap100Cur):'-'}</td>
        <td>${capOeeCur?formatUnits(capOeeCur):'-'}</td>

        <td>${isFinite(vs)?`<span class="badge ${vs<85?'badge-bad':(vs<100?'badge-warn':'badge-good')}">${vs.toFixed(0)}%</span>`:'-'}</td>
        <td>${isFinite(inputReq)?formatUnits(inputReq):'-'}</td>

        <td style="text-align:left">
          <button class="btn-del" data-wbdel="${row.id}">${currentLang==='es'?'Borrar':'Delete'}</button>
        </td>
      `;

      wbBody.appendChild(tr);

      const cells = tr.querySelectorAll('td');
      const getInputAt = (tdIndex) => cells[tdIndex].querySelector('input');
      const getSelectAt = (tdIndex) => cells[tdIndex].querySelector('select');

      const IDX = {
        seq:0, enabled:1, op:2,
        operators:3, shifts:4, hours:5, machines:6, contract:7,
        changeover:10, clean:11, maint:12, other:13,
        udtVal:14, udtUnit:15,
        scrap:17,
        oeeA:19, oeeP:20, oeeQ:21
      };

      const seqInp = getInputAt(IDX.seq);
      const enChk = cells[IDX.enabled].querySelector('input[type="checkbox"]');
      const opInp = getInputAt(IDX.op);
      const operatorsInp = getInputAt(IDX.operators);
      const shiftsInp = getInputAt(IDX.shifts);
      const hoursInp = getInputAt(IDX.hours);
      const machinesInp = getInputAt(IDX.machines);
      const contractInp = getInputAt(IDX.contract);

      const changeInp = getInputAt(IDX.changeover);
      const cleanInp = getInputAt(IDX.clean);
      const maintInp = getInputAt(IDX.maint);
      const otherInp = getInputAt(IDX.other);

      const udtValInp = getInputAt(IDX.udtVal);
      const udtUnitSel = getSelectAt(IDX.udtUnit);

      const scrapInp = getInputAt(IDX.scrap);

      const oeeAInp = getInputAt(IDX.oeeA);
      const oeePInp = getInputAt(IDX.oeeP);
      const oeeQInp = getInputAt(IDX.oeeQ);

      const onChange = ()=>{
        row.seq = parseFloat(seqInp.value)||0;
        row.enabled = !!enChk.checked;
        row.operation = (opInp.value||'').trim();
        row.operators = parseFloat(operatorsInp.value)||0;
        row.shifts = parseFloat(shiftsInp.value)||0;
        row.hours = parseFloat(hoursInp.value)||0;
        row.machines = parseFloat(machinesInp.value)||0;
        row.contractPcd = parseFloat(contractInp.value)||0;

        row.changeoverMin = parseFloat(changeInp.value)||0;
        row.cleanMin = parseFloat(cleanInp.value)||0;
        row.maintMin = parseFloat(maintInp.value)||0;
        row.otherMin = parseFloat(otherInp.value)||0;

        row.udtValue = parseFloat(udtValInp.value)||0;
        row.udtUnit = udtUnitSel.value;

        row.scrapPct = parseFloat(scrapInp.value)||0;

        row.oeeA = parseFloat(oeeAInp.value)||0;
        row.oeeP = parseFloat(oeePInp.value)||0;
        row.oeeQ = parseFloat(oeeQInp.value)||0;

        saveWB();
        renderAll();
      };

      [seqInp, enChk, opInp, operatorsInp, shiftsInp, hoursInp, machinesInp, contractInp,
       changeInp, cleanInp, maintInp, otherInp, udtValInp, udtUnitSel, scrapInp, oeeAInp, oeePInp, oeeQInp
      ].forEach(el=>{
        el.addEventListener('change', onChange);
      });
    });

    wbBody.querySelectorAll('[data-wbdel]').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=btn.getAttribute('data-wbdel');
        wbRows = wbRows.filter(r=>r.id!==id);
        saveWB();
        renderAll();
      });
    });

    computeAndRenderConstraint();
  }

  function computeAndRenderConstraint(){
    const rows = wbRows.filter(r=>r.enabled);
    if(!rows.length){
      wbConstraint.textContent = currentLang==='es' ? 'WB vacío' : 'WB empty';
      wbNextConstraint.textContent = '—';
      wbConstraintNote.textContent = currentLang==='es'
        ? 'Agrega operaciones para identificar el proceso más débil.'
        : 'Add operations to identify the weakest process.';
      return;
    }

    const scored = rows.map(r=>{
      const net = computeNetMinutes(r);
      const oee = computeOeePct(r);
      const ct = getCtTriple(r);
      const capOeeCur = computeCapacityPerDay(net, ct.cur) * oee;
      const contract = clamp(parseFloat(r.contractPcd),0,1e12);
      const vs = (contract>0) ? (capOeeCur/contract*100) : NaN;
      return {r, capOeeCur, contract, vs};
    }).filter(x => isFinite(x.capOeeCur) && x.capOeeCur>=0);

    if(!scored.length){
      wbConstraint.textContent = currentLang==='es' ? 'Sin CT' : 'No CT';
      wbNextConstraint.textContent = '—';
      wbConstraintNote.textContent = currentLang==='es'
        ? 'No hay CT (medición o manual). Captura laps o define CT manual.'
        : 'No CT (study or manual). Capture laps or set manual CT.';
      return;
    }

    const anyContract = scored.some(x => x.contract>0);
    const anyFail = scored.some(x => x.contract>0 && x.vs<100);

    let primary, secondary, note;

    if(anyContract && anyFail){
      scored.sort((a,b)=>{
        const av = isFinite(a.vs)?a.vs:1e18;
        const bv = isFinite(b.vs)?b.vs:1e18;
        return av-bv;
      });
      primary = scored[0];
      secondary = scored[1] || null;
      note = currentLang==='es'
        ? '🔴 Restricción (vs contrato): proceso con menor % vs contrato.'
        : '🔴 Constraint (vs contract): process with the lowest % vs contract.';
      wbConstraint.className = 'badge badge-bad';
      wbNextConstraint.className = 'badge badge-warn';
    }else{
      scored.sort((a,b)=>a.capOeeCur-b.capOeeCur);
      primary = scored[0];
      secondary = scored[1] || null;
      note = currentLang==='es'
        ? '🔴 Proceso con menor salida (todos cumplen contrato o no hay contrato por operación).'
        : '🔴 Lowest output process (all meet contract or no per-operation contract).';
      wbConstraint.className = 'badge badge-bad';
      wbNextConstraint.className = 'badge badge-warn';
    }

    const pTxt = primary ? `${primary.r.operation || '(no name)'} · ${formatUnits(primary.capOeeCur)}/${currentLang==='es'?'día':'day'}${(primary.contract>0 && isFinite(primary.vs))?` · ${primary.vs.toFixed(0)}%`:''}` : '—';
    const sTxt = secondary ? `${secondary.r.operation || '(no name)'} · ${formatUnits(secondary.capOeeCur)}/${currentLang==='es'?'día':'day'}${(secondary.contract>0 && isFinite(secondary.vs))?` · ${secondary.vs.toFixed(0)}%`:''}` : '—';

    wbConstraint.textContent = pTxt;
    wbNextConstraint.textContent = sTxt;
    wbConstraintNote.textContent = note;
  }

  function buildMethodGuide(){
    if(currentLang==='es'){
      return `Cómo TaktLab estima capacidad (WB)
• CT (tiempos ciclo): si existe estudio (laps) con Process == Operation, se toma:
  - Actual = Mediana (CTmed)
  - Peor = P90
  - Potencial = P10
• Gross minutes/día = Hours × 60 × Shifts × #Machines
• Lunch (auto): depende de Hours por turno (15/30/45/60 min) × Shifts
• Pérdidas editables (min/día): Changeover, 5S/Limpieza, Maintenance, Other
• Unplanned DT: editable en min/día o seg/h (se convierte a min/día)
• Net minutes/día = Gross − Lunch − pérdidas − Unplanned DT
• Capacidad 100% (pzs/día) = (Net minutes × 60) / CT
• OEE por operación:
  - Capturas A, P, Q en %
  - OEE = (A×P×Q)  → siempre queda entre 0% y 100%
  - Cap@OEE = Capacidad 100% × OEE
  - CT@OEE = CT / OEE
Scrap (por proceso)
• Yield = 1 − Scrap%
• Para cumplir un contrato de salida (pzs buenas):
  - Input requerido = Contract / Yield
Restricción
• Si alguna operación NO cumple su contrato → restricción = menor % vs contrato.
• Si TODAS cumplen → se marca “Proceso con menor salida”.`;
    }

    return `How TaktLab estimates capacity (WB)
• CT (cycle times): if a time study exists (laps) where Process == Operation:
  - Current = Median (CTmed)
  - Worst = P90
  - Potential = P10
• Gross min/day = Hours × 60 × Shifts × #Machines
• Lunch (auto): based on Hours/shift (15/30/45/60 min) × Shifts
• Editable losses (min/day): Changeover, 5S/Cleaning, Maintenance, Other
• Unplanned Downtime: min/day or sec/hr (converted)
• Net min/day = Gross − Lunch − losses − Unplanned DT
• Capacity 100% (pcs/day) = (Net minutes × 60) / CT
• OEE per operation:
  - You enter A, P, Q in %
  - OEE = (A×P×Q) → always 0%..100%
  - Cap@OEE = Capacity 100% × OEE
  - CT@OEE = CT / OEE
Scrap
• Yield = 1 − Scrap%
• Required input = Contract / Yield
Constraint
• If any operation fails contract → constraint = lowest % vs contract.
• If all meet → “Lowest output process”.`;
  }

  btnWbAdd.addEventListener('click',()=>{
    const r = defaultWbRow();
    const maxSeq = wbRows.reduce((m,x)=>Math.max(m, parseFloat(x.seq)||0), 0);
    r.seq = (maxSeq||0) + 10;
    r.operation = (processInput.value||'').trim() || '';
    // defaults from measurement setup
    r.hours = clamp(parseFloat(hInput.value)||8,1,24);
    r.contractPcd = Math.max(0, parseFloat(pcdInput.value)||0);
    r.oeeQ = clamp(parseFloat(effInput.value)||100,0,100);
    wbRows.push(r);
    saveWB();
    renderAll();
    setTimeout(()=>{
      const last = wbBody.querySelector('tr:last-child td:nth-child(3) input');
      if(last) last.focus();
    }, 50);
  });

  btnWbClear.addEventListener('click',()=>{
    const ok = confirm(currentLang==='es'?'¿Borrar WB completo? (no borra laps)':'Clear WB completely? (does not delete laps)');
    if(!ok) return;
    wbRows = [];
    saveWB();
    renderAll();
  });

  // charts
  function updateChartOptions(){
    const groups=groupByProcess();
    const prev=chartSelect.value;
    chartSelect.innerHTML='';
    if(!groups.size){
      const opt=document.createElement('option');
      opt.value=''; opt.textContent=currentLang==='es'?'Sin procesos aún':'No process yet';
      chartSelect.appendChild(opt);
      drawTimeSeries(null,null);
      drawHistogram(null,null);
      return;
    }
    let first=null;
    [...groups.keys()].forEach(key=>{
      if(!first) first=key;
      const [p,m]=key.split('||');
      const opt=document.createElement('option');
      opt.value=key; opt.textContent=`${p} (${m})`;
      chartSelect.appendChild(opt);
    });
    chartSelect.value = (prev && groups.has(prev)) ? prev : first;
    renderCharts();
  }

  function renderCharts(){
    const key=chartSelect.value;
    const groups=groupByProcess();
    if(!key || !groups.has(key)){ drawTimeSeries(null,null); drawHistogram(null,null); return; }
    const arr=groups.get(key);
    const st=calcStats(arr);
    drawTimeSeries(arr,st);
    drawHistogram(arr,st);
  }

  function fitCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function drawTimeSeries(arr,st){
    fitCanvas(timeSeriesCanvas);
    const ctx=timeSeriesCanvas.getContext('2d');
    const w=timeSeriesCanvas.getBoundingClientRect().width;
    const h=timeSeriesCanvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#020b1a'; ctx.fillRect(0,0,w,h);

    if(!arr || !arr.length || !st || st.n<3){
      ctx.fillStyle='#607d8b'; ctx.font='12px system-ui';
      ctx.fillText(currentLang==='es'?'Se requieren al menos 3 muestras.':'Need at least 3 samples.',10,20);
      return;
    }

    const vals=st.values;
    let min=st.min, max=st.max;
    if(min===max){min-=0.5;max+=0.5;}
    const padL=35,padR=8,padT=10,padB=18;
    const innerW=w-padL-padR, innerH=h-padT-padB;

    const yScale=v=>padT+innerH*(1-(v-min)/(max-min));
    const xScale=i=>vals.length===1?(padL+innerW/2):(padL+innerW*(i/(vals.length-1)));

    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
    ctx.beginPath();
    for(let g=0;g<=4;g++){
      const y=padT+innerH*g/4;
      ctx.moveTo(padL,y); ctx.lineTo(w-padR,y);
    }
    ctx.stroke();

    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,h-padB); ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    ctx.fillStyle='#90a4ae'; ctx.font='10px system-ui';
    for(let g=0;g<=4;g++){
      const val=min+(max-min)*g/4;
      const y=padT+innerH*(1-g/4);
      ctx.fillText(formatSecs(val),2,y+3);
    }

    ctx.strokeStyle='#29b6f6'; ctx.lineWidth=2; ctx.beginPath();
    vals.forEach((v,i)=>{ const x=xScale(i), y=yScale(v); i?ctx.lineTo(x,y):ctx.moveTo(x,y); });
    ctx.stroke();

    ctx.fillStyle='#29b6f6';
    vals.forEach((v,i)=>{ const x=xScale(i), y=yScale(v); ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill(); });

    ctx.setLineDash([4,3]);
    if(st.std>0){
      const ucl=st.mean+3*st.std;
      const lcl=st.mean-3*st.std;
      ctx.strokeStyle='rgba(255,82,82,0.9)';
      ctx.beginPath();
      ctx.moveTo(padL,yScale(ucl)); ctx.lineTo(w-padR,yScale(ucl));
      ctx.moveTo(padL,yScale(lcl)); ctx.lineTo(w-padR,yScale(lcl));
      ctx.stroke();
    }
    ctx.strokeStyle='rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.moveTo(padL,yScale(st.mean)); ctx.lineTo(w-padR,yScale(st.mean)); ctx.stroke();

    ctx.strokeStyle='rgba(0,230,118,0.9)';
    ctx.beginPath(); ctx.moveTo(padL,yScale(st.median)); ctx.lineTo(w-padR,yScale(st.median)); ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawHistogram(arr,st){
    fitCanvas(histCanvas);
    const ctx=histCanvas.getContext('2d');
    const w=histCanvas.getBoundingClientRect().width;
    const h=histCanvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#020b1a'; ctx.fillRect(0,0,w,h);

    if(!arr || !arr.length || !st || st.n<3){
      ctx.fillStyle='#607d8b'; ctx.font='12px system-ui';
      ctx.fillText(currentLang==='es'?'Se requieren más muestras.':'Need more samples.',10,20);
      return;
    }

    const vals=st.values;
    let min=st.min, max=st.max;
    if(min===max){min-=0.5;max+=0.5;}
    const padL=30,padR=8,padT=8,padB=20;
    const innerW=w-padL-padR, innerH=h-padT-padB;
    const binsCount=8;
    const binSize=(max-min)/binsCount;
    const bins=new Array(binsCount).fill(0);
    vals.forEach(v=>{
      let idx=Math.floor((v-min)/binSize);
      if(idx===binsCount) idx=binsCount-1;
      bins[idx]++;
    });
    const maxBin=Math.max(...bins);

    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,h-padB); ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    const barW=innerW/binsCount;
    ctx.fillStyle='#29b6f6';
    bins.forEach((c,i)=>{
      const x=padL+i*barW+1;
      const barH=maxBin?innerH*(c/maxBin):0;
      const y=(h-padB)-barH;
      ctx.fillRect(x,y,barW-2,barH);
    });

    const medX=padL+innerW*((st.median-min)/(max-min));
    ctx.strokeStyle='#00e676';
    ctx.beginPath(); ctx.moveTo(medX,padT); ctx.lineTo(medX,h-padB); ctx.stroke();

    const p10x=padL+innerW*((st.p10-min)/(max-min));
    const p90x=padL+innerW*((st.p90-min)/(max-min));
    ctx.strokeStyle='rgba(255,241,118,0.9)';
    ctx.beginPath();
    ctx.moveTo(p10x,padT); ctx.lineTo(p10x,h-padB);
    ctx.moveTo(p90x,padT); ctx.lineTo(p90x,h-padB);
    ctx.stroke();
  }

  async function copyToClipboard(text){
    if(!text) return;
    try{ await navigator.clipboard.writeText(text); alert(currentLang==='es'?'Copiado.':'Copied.'); }
    catch(e){
      const ta=document.createElement('textarea'); ta.value=text;
      document.body.appendChild(ta); ta.select();
      try{ document.execCommand('copy'); alert(currentLang==='es'?'Copiado.':'Copied.'); }
      catch(err){ alert(currentLang==='es'?'No disponible el portapapeles.':'Clipboard not available.'); }
      document.body.removeChild(ta);
    }
  }

  btnCopyAll.addEventListener('click',()=>{
    if(!laps.length){ alert(currentLang==='es'?'No hay datos.':'No data.'); return; }
    const header = currentLang==='es'
      ? ['#','Proceso','Modo','Estatus','Nota','T1 (s)','T2 (s)','Total (s)']
      : ['#','Process','Mode','Status','Note','T1 (s)','T2 (s)','Total (s)'];

    const rows=laps.map((l,i)=>[
      i+1,l.process,l.mode,l.status||'',l.note||'',
      formatSecs(l.t1),formatSecs(l.t2),formatSecs(l.total)
    ].join('\t'));
    copyToClipboard(header.join('\t')+'\n'+rows.join('\n'));
  });

  btnCopySum.addEventListener('click',()=>{
    const lines=[];
    lines.push(currentLang==='es'?'Resumen (WB + Stats)':'Summary (WB + Stats)');
    lines.push('—');
    lines.push((currentLang==='es'?'Restricción: ':'Constraint: ')+wbConstraint.textContent);
    lines.push((currentLang==='es'?'Siguiente: ':'Next: ')+wbNextConstraint.textContent);
    lines.push('—');
    lines.push(currentLang==='es'?'WB (por operación):':'WB (by operation):');

    const enabled = wbRows.filter(r=>r.enabled).slice().sort((a,b)=>(a.seq||0)-(b.seq||0));
    enabled.forEach(r=>{
      const net = computeNetMinutes(r);
      const oee = computeOeePct(r);
      const ct = getCtTriple(r);
      const capOeeCur = computeCapacityPerDay(net, ct.cur)*oee;
      lines.push(`${r.seq} | ${r.operation||'(no name)'} | Cap@OEE ${formatUnits(capOeeCur)}/${currentLang==='es'?'día':'day'} | Contract ${formatUnits(r.contractPcd||0)} | Scrap ${pct(clamp(r.scrapPct,0,100),1)}`);
    });

    lines.push('—');
    lines.push(currentLang==='es'?'Nota: usa "Copy All" para datos crudos.':'Note: use "Copy All" for raw data.');
    copyToClipboard(lines.join('\n'));
  });

  function renderAll(){
    renderDataTable();
    renderFocusTable();
    renderStatsDetail();
    updateChartOptions();
    updateSemaphores();
    renderWB();
    methodGuideText.textContent = buildMethodGuide();
  }

  chartSelect.addEventListener('change',renderCharts);
  window.addEventListener('resize',renderCharts);

  effInput.addEventListener('change',renderAll);
  pcdInput.addEventListener('change',renderAll);
  hInput.addEventListener('change',renderAll);
  dInput.addEventListener('change',renderAll);
  capViewSel.addEventListener('change',renderAll);

  loadWB();
  updateDisplay();
  refreshRingStates();
  setLanguage(currentLang);
})();
</script>
</body>
</html>
