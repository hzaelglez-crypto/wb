<script>
(function(){
    // --- REFERENCIAS DOM ---
    const display = document.getElementById('display');
    const btnStart = document.getElementById('btnStart');
    const btnLap = document.getElementById('btnLap');
    const t1Clock = document.getElementById('t1Clock');
    const t2Clock = document.getElementById('t2Clock');
    const dataBody = document.getElementById('dataBody');
    const logoGear = document.getElementById('logoGear');

    // --- VARIABLES DE ESTADO ---
    let mainStartTime = 0;
    let lapStartTime = 0;
    let t1StartTime = 0;
    let elapsedTime = 0;
    let timerInterval = null;
    let isRunning = false;
    let currentT1 = 0;
    let currentT2 = 0;

    // DATA CORE (Carga inicial)
    let laps = JSON.parse(localStorage.getItem('taktlab_data')) || [];

    // --- MOTOR DEL CRONÓMETRO ---
    function updateClocks() {
        const now = Date.now();
        const totalMs = now - mainStartTime + elapsedTime;
        const lapMs = now - lapStartTime;

        // Display Principal (MM:SS.ms)
        display.textContent = formatMs(totalMs);

        const mode = document.getElementById('mode').value;
        if (mode === 'MLD') {
            // Lógica T1/T2: T1 es el tiempo desde el inicio del lap hasta ahora
            // En esta versión simplificada, T1 corre hasta que se presiona Lap
            t1Clock.textContent = formatMs(lapMs);
            t2Clock.textContent = "00:00.00"; 
        } else {
            t1Clock.textContent = formatMs(lapMs);
            t2Clock.textContent = "---";
        }
    }

    function formatMs(ms) {
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        const centis = Math.floor((ms % 1000) / 10);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${centis.toString().padStart(2, '0')}`;
    }

    // --- ACCIONES ---
    btnStart.onclick = () => {
        if (!isRunning) {
            mainStartTime = Date.now();
            lapStartTime = mainStartTime;
            timerInterval = setInterval(updateClocks, 30);
            isRunning = true;
            btnStart.textContent = "PAUSAR";
            btnStart.style.background = "var(--accent-amber)";
            btnLap.disabled = false;
            logoGear.classList.add('spinning');
        } else {
            clearInterval(timerInterval);
            elapsedTime += Date.now() - mainStartTime;
            isRunning = false;
            btnStart.textContent = "REANUDAR";
            btnStart.style.background = "var(--accent-green)";
            logoGear.classList.remove('spinning');
        }
    };

    btnLap.onclick = () => {
        const now = Date.now();
        const lapTimeTotal = (now - lapStartTime) / 1000;
        
        const newLap = {
            id: laps.length + 1,
            process: document.getElementById('processName').value || "Op General",
            mode: document.getElementById('mode').value,
            t1: lapTimeTotal, // En Parte 2 refinaremos la separación exacta T1/T2
            t2: 0,
            total: lapTimeTotal,
            timestamp: new Date().toLocaleTimeString()
        };

        laps.push(newLap);
        lapStartTime = now; // Reset lap
        
        // Efecto visual flash
        document.getElementById('timerCard').classList.add('flash');
        setTimeout(() => document.getElementById('timerCard').classList.remove('flash'), 150);
        
        saveAndRender();
    };

    document.getElementById('btnReset').onclick = () => {
        if (confirm("¿Reiniciar estudio? Se perderán los datos actuales.")) {
            clearInterval(timerInterval);
            laps = [];
            elapsedTime = 0;
            isRunning = false;
            localStorage.removeItem('taktlab_data');
            display.textContent = "00:00.00";
            t1Clock.textContent = "00:00.00";
            btnStart.textContent = "INICIAR";
            btnStart.style.background = "var(--accent-green)";
            btnLap.disabled = true;
            saveAndRender();
        }
    };

    // --- PERSISTENCIA Y RENDER ---
    function saveAndRender() {
        localStorage.setItem('taktlab_data', JSON.stringify(laps));
        renderTable();
        // Aquí se llamará a updateStats() en la Parte 2
    }

    function renderTable() {
        dataBody.innerHTML = '';
        [...laps].reverse().forEach((lap) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${lap.id}</td>
                <td>${lap.process}</td>
                <td>${lap.mode}</td>
                <td><span class="badge badge-good">OK</span></td>
                <td>-</td>
                <td>${lap.t1.toFixed(2)}</td>
                <td>${lap.t2.toFixed(2)}</td>
                <td><b>${lap.total.toFixed(2)}</b></td>
                <td><button class="btn-edit" onclick="alert('Próximamente')">✎</button></td>
                <td><button class="btn-del" onclick="deleteLap(${lap.id})">✖</button></td>
            `;
            dataBody.appendChild(row);
        });
    }

    window.deleteLap = (id) => {
        laps = laps.filter(l => l.id !== id);
        saveAndRender();
    };

    // Inicialización
    saveAndRender();

})();
</script>(function(){
    // --- REFERENCIAS DOM ---
    const display = document.getElementById('display'), btnStart = document.getElementById('btnStart'), btnLap = document.getElementById('btnLap');
    const t1Clock = document.getElementById('t1Clock'), t2Clock = document.getElementById('t2Clock');
    const dataBody = document.getElementById('dataBody'), focusBody = document.getElementById('focusBody'), statsBody = document.getElementById('statsBody');
    const logoGear = document.getElementById('logoGear'), timerCard = document.getElementById('timerCard');

    // Inputs de Configuración
    const effIn = document.getElementById('efficiency'), pcdIn = document.getElementById('contractPcd');
    const hrsIn = document.getElementById('hoursPerDay'), daysIn = document.getElementById('daysPerWeek'), capView = document.getElementById('capView');

    // --- ESTADO ---
    let mainStartTime = 0, lapStartTime = 0, elapsedTime = 0, timerInterval = null, isRunning = false;
    let laps = JSON.parse(localStorage.getItem('taktlab_data')) || [];
    let charts = {}; // Para guardar instancias de Chart.js

    // --- MOTOR CRONÓMETRO ---
    function updateClocks() {
        const now = Date.now(), totalMs = now - mainStartTime + elapsedTime, lapMs = now - lapStartTime;
        display.textContent = formatMs(totalMs);
        t1Clock.textContent = formatMs(lapMs);
    }

    function formatMs(ms) {
        const m = Math.floor(ms / 60000), s = Math.floor((ms % 60000) / 1000), c = Math.floor((ms % 1000) / 10);
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${c.toString().padStart(2, '0')}`;
    }

    // --- ACCIONES ---
    btnStart.onclick = () => {
        if (!isRunning) {
            mainStartTime = Date.now(); lapStartTime = mainStartTime;
            timerInterval = setInterval(updateClocks, 30);
            isRunning = true; btnStart.textContent = "PAUSAR"; btnStart.style.background = "var(--btn-orange)";
            btnLap.disabled = false; logoGear.classList.add('spinning');
        } else {
            clearInterval(timerInterval); elapsedTime += Date.now() - mainStartTime;
            isRunning = false; btnStart.textContent = "REANUDAR"; btnStart.style.background = "var(--btn-green)";
            logoGear.classList.remove('spinning');
        }
    };

    btnLap.onclick = () => {
        const now = Date.now(), lapSec = (now - lapStartTime) / 1000;
        laps.push({
            id: laps.length + 1,
            process: document.getElementById('processName').value || "Op General",
            mode: document.getElementById('mode').value,
            total: lapSec,
            t1: lapSec, t2: 0,
            timestamp: new Date().toLocaleTimeString()
        });
        lapStartTime = now;
        timerCard.classList.add('flash');
        setTimeout(() => timerCard.classList.remove('flash'), 100);
        saveAndSync();
    };

    document.getElementById('btnReset').onclick = () => {
        if(confirm("¿Borrar todo?")) { 
            laps = []; elapsedTime = 0; isRunning = false; clearInterval(timerInterval);
            localStorage.removeItem('taktlab_data'); location.reload();
        }
    };

    // --- CÁLCULOS ESTADÍSTICOS ---
    function getStats(vals) {
        if(!vals.length) return null;
        const sorted = [...vals].sort((a,b)=>a-b);
        const sum = sorted.reduce((a,b)=>a+b,0);
        const mean = sum / sorted.length;
        const median = sorted[Math.floor(sorted.length / 2)];
        const p10 = sorted[Math.floor(sorted.length * 0.1)];
        const p90 = sorted[Math.floor(sorted.length * 0.9)];
        const std = Math.sqrt(sorted.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / sorted.length);
        const cv = (std / mean) * 100;
        return { mean, median, p10, p90, std, cv, n: sorted.length, min: sorted[0], max: sorted[sorted.length-1] };
    }

    function calculateCapacity(ct, eff, hrs, days, view) {
        if(!ct || ct === 0) return 0;
        const secAvailableDay = hrs * 3600 * (eff / 100);
        const capDay = secAvailableDay / ct;
        if(view === 'hour') return capDay / hrs;
        if(view === 'week') return capDay * days;
        return capDay;
    }

    // --- RENDERIZADO Y SYNC ---
    function saveAndSync() {
        localStorage.setItem('taktlab_data', JSON.stringify(laps));
        renderRaw();
        const stats = getStats(laps.map(l => l.total));
        if(stats) {
            renderFocus(stats);
            renderStatsTable(stats);
            updateCharts(laps.map(l => l.total), stats);
            updateTopInfo(stats);
        }
    }

    function renderFocus(s) {
        const eff = parseFloat(effIn.value), hrs = parseFloat(hrsIn.value), days = parseFloat(daysIn.value), view = capViewSel.value;
        const target = parseFloat(pcdIn.value);
        
        const capAct = calculateCapacity(s.median, eff, hrs, days, view);
        const capPot = calculateCapacity(s.p10, eff, hrs, days, view);
        const capWst = calculateCapacity(s.p90, eff, hrs, days, view);

        focusBody.innerHTML = `<tr>
            <td>${document.getElementById('processName').value}</td>
            <td>${document.getElementById('mode').value}</td>
            <td>${s.n}</td>
            <td>±3% @ N=384</td>
            <td>${s.std.toFixed(2)}</td>
            <td>${s.cv.toFixed(1)}%</td>
            <td>${s.median.toFixed(2)}s</td>
            <td>${s.p10.toFixed(2)}s</td>
            <td>${s.p90.toFixed(2)}s</td>
            <td class="badge-good">${Math.round(capAct)}</td>
            <td style="color:var(--accent-blue)">${Math.round(capPot)}</td>
            <td style="color:var(--accent-red)">${Math.round(capWst)}</td>
            <td>${target}</td>
            <td>${Math.round(capAct - target)}</td>
            <td>${target > 0 ? ((capAct/target)*100).toFixed(1) : 0}%</td>
            <td>-</td><td>-</td><td>-</td>
        </tr>`;
    }

    function renderStatsTable(s) {
        statsBody.innerHTML = `<tr>
            <td>${document.getElementById('processName').value}</td>
            <td>${document.getElementById('mode').value}</td>
            <td>${s.n}</td>
            <td>${s.mean.toFixed(2)}</td>
            <td>${s.median.toFixed(2)}</td>
            <td>${s.p10.toFixed(2)}</td>
            <td>${s.p90.toFixed(2)}</td>
            <td>${s.min.toFixed(2)}</td>
            <td>${s.max.toFixed(2)}</td>
            <td>${s.std.toFixed(2)}</td>
            <td>${s.cv.toFixed(1)}%</td>
            <td>-</td><td>-</td>
        </tr>`;
    }

    function renderRaw() {
        dataBody.innerHTML = '';
        [...laps].reverse().forEach(l => {
            dataBody.innerHTML += `<tr>
                <td>${l.id}</td><td>${l.process}</td><td>${l.mode}</td>
                <td><span class="badge badge-good">OK</span></td>
                <td>-</td><td>${l.t1.toFixed(2)}</td><td>0.00</td>
                <td><b>${l.total.toFixed(2)}</b></td>
                <td><button class="btn-edit" onclick="alert('Editar ID: '+${l.id})">✎</button></td>
                <td><button class="btn-del" onclick="window.deleteLap(${l.id})">✖</button></td>
            </tr>`;
        });
    }

    function updateTopInfo(s) {
        const info = document.getElementById('sampleInfoTop');
        if(s.n < 10) {
            info.className = "info-line sample-warn";
            info.textContent = `Muestra pequeña (N=${s.n}). Se recomiendan +10 para estabilidad. CV: ${s.cv.toFixed(1)}%`;
        } else {
            info.className = "info-line sample-good";
            info.textContent = `Estudio Robusto (N=${s.n}). Variación: ${s.cv < 10 ? 'Baja' : 'Alta'} (${s.cv.toFixed(1)}%).`;
        }
    }

    window.deleteLap = (id) => { laps = laps.filter(l => l.id !== id); saveAndSync(); };

    // --- GRÁFICAS (Chart.js) ---
    function updateCharts(data, s) {
        const ctxTime = document.getElementById('timeSeriesCanvas').getContext('2d');
        if(charts.time) charts.time.destroy();
        charts.time = new Chart(ctxTime, {
            type: 'line',
            data: {
                labels: data.map((_,i)=>i+1),
                datasets: [{
                    label: 'Ciclos', data: data, borderColor: '#39bdf5', tension: 0.2, fill: false
                }, {
                    label: 'Mediana', data: Array(data.length).fill(s.median), borderColor: '#f2c14e', borderDash: [5,5], pointRadius: 0
                }]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: false } } }
        });

        // Histograma simplificado
        const ctxHist = document.getElementById('histCanvas').getContext('2d');
        if(charts.hist) charts.hist.destroy();
        const bins = 5; 
        const min = s.min, max = s.max, range = (max - min) / bins;
        const counts = Array(bins).fill(0);
        data.forEach(v => { const b = Math.min(Math.floor((v-min)/range), bins-1); counts[b]++; });

        charts.hist = new Chart(ctxHist, {
            type: 'bar',
            data: {
                labels: counts.map((_,i)=>(min + (i*range)).toFixed(1)+'s'),
                datasets: [{ label: 'Frecuencia', data: counts, backgroundColor: '#18c97a' }]
            },
            options: { responsive: true, maintainAspectRatio: false }
        });
    }

    // Escuchadores de cambios en inputs para recalcular capacidad en vivo
    [effIn, pcdIn, hrsIn, daysIn, capViewSel].forEach(el => el.oninput = saveAndSync);

    // Init
    saveAndSync();
})();
</script>(function(){
    // --- REFERENCIAS DOM ---
    const display = document.getElementById('display'), btnStart = document.getElementById('btnStart'), btnLap = document.getElementById('btnLap');
    const t1Clock = document.getElementById('t1Clock'), t2Clock = document.getElementById('t2Clock');
    const dataBody = document.getElementById('dataBody'), focusBody = document.getElementById('focusBody');
    const wbBody = document.getElementById('wbBody'), wbOperatorsSum = document.getElementById('wbOperatorsSum');
    const wbConstraint = document.getElementById('wbConstraint'), wbNextConstraint = document.getElementById('wbNextConstraint');

    // --- ESTADO ---
    let mainStartTime = 0, lapStartTime = 0, elapsedTime = 0, timerInterval = null, isRunning = false;
    let laps = JSON.parse(localStorage.getItem('taktlab_data')) || [];
    let wbData = JSON.parse(localStorage.getItem('taktlab_wb')) || [];
    let charts = {};

    // --- MOTOR CRONÓMETRO (IGUAL A P1/P2) ---
    function formatMs(ms) {
        const m = Math.floor(ms / 60000), s = Math.floor((ms % 60000) / 1000), c = Math.floor((ms % 1000) / 10);
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${c.toString().padStart(2, '0')}`;
    }
    btnStart.onclick = () => {
        if (!isRunning) {
            mainStartTime = Date.now(); lapStartTime = mainStartTime;
            timerInterval = setInterval(() => {
                const now = Date.now(), totalMs = now - mainStartTime + elapsedTime, lapMs = now - lapStartTime;
                display.textContent = formatMs(totalMs); t1Clock.textContent = formatMs(lapMs);
            }, 30);
            isRunning = true; btnStart.textContent = "PAUSAR"; btnStart.style.background = "var(--btn-orange)";
            btnLap.disabled = false; document.getElementById('logoGear').classList.add('spinning');
        } else {
            clearInterval(timerInterval); elapsedTime += Date.now() - mainStartTime;
            isRunning = false; btnStart.textContent = "REANUDAR"; btnStart.style.background = "var(--btn-green)";
            document.getElementById('logoGear').classList.remove('spinning');
        }
    };
    btnLap.onclick = () => {
        const now = Date.now(), lapSec = (now - lapStartTime) / 1000;
        laps.push({ id: laps.length + 1, process: document.getElementById('processName').value || "Op General", mode: document.getElementById('mode').value, total: lapSec, t1: lapSec, t2: 0 });
        lapStartTime = now; saveAndSync();
    };

    // --- LÓGICA WORKBENCH (NUEVO) ---
    document.getElementById('btnWbAdd').onclick = () => {
        const stats = getStats(laps.map(l => l.total));
        wbData.push({
            id: Date.now(), enabled: true, opName: document.getElementById('processName').value || "Nueva Op",
            operators: 1, shifts: 3, hours: 8, machines: 1, pcsPerOp: 1, 
            contract: parseFloat(document.getElementById('contractPcd').value) || 0,
            lunch: 60, changeover: 0, cleaning: 10, maint: 0, other: 0, shared: 0, unplannedDt: 30,
            scrap: 2, availability: 95, performance: 95, quality: 98,
            ctCur: stats ? stats.median : 0, ctWst: stats ? stats.p90 : 0, ctPot: stats ? stats.p10 : 0
        });
        saveAndSync();
    };

    function calculateWbRow(row) {
        const grossMin = row.shifts * row.hours * 60;
        const plannedLoss = row.lunch + row.changeover + row.cleaning + row.maint + row.other + row.shared;
        const netMin = (grossMin - plannedLoss - row.unplannedDt) * row.machines;
        const yieldVal = (100 - row.scrap) / 100;
        
        // OEE Simplificado para el WB
        const oee = (row.availability/100) * (row.performance/100) * (row.quality/100);
        const ctOee = row.ctCur / oee;
        
        const cap100 = (netMin * 60 / row.ctCur) * row.pcsPerOp;
        const capOee = cap100 * oee;
        const vsContract = row.contract > 0 ? (capOee / row.contract) * 100 : 0;

        return { ...row, grossMin, netMin, yieldVal, oee, capOee, vsContract };
    }

    function renderWB() {
        wbBody.innerHTML = '';
        let totalOps = 0;
        let results = [];

        wbData.forEach((row, idx) => {
            const res = calculateWbRow(row);
            results.push(res);
            if(res.enabled) totalOps += parseFloat(res.operators);

            wbBody.innerHTML += `
                <tr>
                    <td><input type="checkbox" ${res.enabled?'checked':''} onchange="updateWbField(${idx}, 'enabled', this.checked)"></td>
                    <td><input class="wb-inp wide" value="${res.opName}" onchange="updateWbField(${idx}, 'opName', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.operators}" onchange="updateWbField(${idx}, 'operators', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.shifts}" onchange="updateWbField(${idx}, 'shifts', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.hours}" onchange="updateWbField(${idx}, 'hours', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.machines}" onchange="updateWbField(${idx}, 'machines', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.pcsPerOp}" onchange="updateWbField(${idx}, 'pcsPerOp', this.value)"></td>
                    <td><input class="wb-inp" type="number" value="${res.contract}" onchange="updateWbField(${idx}, 'contract', this.value)"></td>
                    <td class="sample-neutral">${res.grossMin}</td>
                    <td><input class="wb-inp slim" type="number" value="${res.lunch}" onchange="updateWbField(${idx}, 'lunch', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.changeover}" onchange="updateWbField(${idx}, 'changeover', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.cleaning}" onchange="updateWbField(${idx}, 'cleaning', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.maint}" onchange="updateWbField(${idx}, 'maint', this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${res.other}" onchange="updateWbField(${idx}, 'other', this.value)"></td>
                    <td style="background:#fff3e0">${res.shared}</td>
                    <td><input class="wb-inp slim" type="number" value="${res.unplannedDt}" onchange="updateWbField(${idx}, 'unplannedDt', this.value)"></td>
                    <td class="badge-good">${res.netMin.toFixed(0)}</td>
                    <td>${res.scrap}%</td>
                    <td>${res.yieldVal.toFixed(2)}</td>
                    <td>${res.availability}%</td>
                    <td>${res.performance}%</td>
                    <td>${res.quality}%</td>
                    <td style="font-weight:bold">${(res.oee*100).toFixed(1)}%</td>
                    <td>${res.ctCur.toFixed(2)}s</td>
                    <td>${res.ctWst.toFixed(2)}s</td>
                    <td>${res.ctPot.toFixed(2)}s</td>
                    <td>${(res.ctCur / res.oee).toFixed(2)}s</td>
                    <td>${Math.round(res.capOee / res.oee)}</td>
                    <td style="background:var(--badge-green)">${Math.round(res.capOee)}</td>
                    <td class="${res.vsContract < 100 ? 'badge-bad' : 'badge-good'}">${res.vsContract.toFixed(1)}%</td>
                    <td>${Math.round(res.contract / res.yieldVal)}</td>
                    <td><button class="btn-del" onclick="removeWb(${idx})">✖</button></td>
                </tr>`;
        });

        wbOperatorsSum.textContent = totalOps;
        updateConstraint(results);
    }

    function updateConstraint(results) {
        const active = results.filter(r => r.enabled && r.capOee > 0);
        if(!active.length) return;
        
        const sorted = [...active].sort((a,b) => a.capOee - b.capOee);
        wbConstraint.textContent = `${sorted[0].opName} (${Math.round(sorted[0].capOee)} pzs)`;
        if(sorted.length > 1) {
            wbNextConstraint.textContent = `${sorted[1].opName} (${Math.round(sorted[1].capOee)} pzs)`;
        }
    }

    window.updateWbField = (idx, field, val) => {
        wbData[idx][field] = field === 'enabled' || field === 'opName' ? val : parseFloat(val);
        saveAndSync();
    };

    window.removeWb = (idx) => { wbData.splice(idx, 1); saveAndSync(); };
    document.getElementById('btnWbClear').onclick = () => { if(confirm("¿Vaciar WB?")) { wbData = []; saveAndSync(); } };

    // --- REUTILIZAR FUNCIONES P2 ---
    function getStats(vals) {
        if(!vals.length) return null;
        const sorted = [...vals].sort((a,b)=>a-b);
        const mean = sorted.reduce((a,b)=>a+b,0) / sorted.length;
        return { median: sorted[Math.floor(sorted.length / 2)], p10: sorted[Math.floor(sorted.length * 0.1)], p90: sorted[Math.floor(sorted.length * 0.9)], n: sorted.length };
    }

    function saveAndSync() {
        localStorage.setItem('taktlab_data', JSON.stringify(laps));
        localStorage.setItem('taktlab_wb', JSON.stringify(wbData));
        renderWB();
        // (Aquí llamarías a renderRaw y renderFocus de la Parte 2)
    }

    saveAndSync();
})();
</script>(function(){
    // --- REFERENCIAS DOM ---
    const display = document.getElementById('display'), btnStart = document.getElementById('btnStart'), btnLap = document.getElementById('btnLap');
    const t1Clock = document.getElementById('t1Clock'), t2Clock = document.getElementById('t2Clock');
    const dataBody = document.getElementById('dataBody'), focusBody = document.getElementById('focusBody');
    const wbBody = document.getElementById('wbBody'), scBody = document.getElementById('scBody');
    const wbOperatorsSum = document.getElementById('wbOperatorsSum'), wbConstraint = document.getElementById('wbConstraint');

    // --- ESTADO ---
    let mainStartTime = 0, lapStartTime = 0, elapsedTime = 0, timerInterval = null, isRunning = false;
    let laps = JSON.parse(localStorage.getItem('taktlab_data')) || [];
    let wbData = JSON.parse(localStorage.getItem('taktlab_wb')) || [];
    let scData = JSON.parse(localStorage.getItem('taktlab_sc')) || []; // Shared Capacity Data

    // --- MOTOR CRONÓMETRO (BASE) ---
    function formatMs(ms) {
        const m = Math.floor(ms/60000), s = Math.floor((ms%60000)/1000), c = Math.floor((ms%1000)/10);
        return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${c.toString().padStart(2,'0')}`;
    }
    btnStart.onclick = () => {
        if (!isRunning) {
            mainStartTime = Date.now(); lapStartTime = mainStartTime;
            timerInterval = setInterval(() => {
                const now = Date.now(), totalMs = now - mainStartTime + elapsedTime, lapMs = now - lapStartTime;
                display.textContent = formatMs(totalMs); t1Clock.textContent = formatMs(lapMs);
            }, 30);
            isRunning = true; btnStart.textContent = "PAUSAR"; btnStart.style.background = "var(--btn-orange)";
            btnLap.disabled = false; document.getElementById('logoGear').classList.add('spinning');
        } else {
            clearInterval(timerInterval); elapsedTime += Date.now() - mainStartTime;
            isRunning = false; btnStart.textContent = "REANUDAR"; btnStart.style.background = "var(--btn-green)";
            document.getElementById('logoGear').classList.remove('spinning');
        }
    };
    btnLap.onclick = () => {
        const now = Date.now(), lapSec = (now - lapStartTime) / 1000;
        laps.push({ id: laps.length + 1, process: document.getElementById('processName').value || "Op General", mode: document.getElementById('mode').value, total: lapSec, t1: lapSec, t2: 0 });
        lapStartTime = now; saveAndSync();
    };

    // --- MÓDULO 4: SHARED CAPACITY LOGIC ---
    document.getElementById('btnScAddMachine').onclick = () => {
        scData.push({
            id: Date.now(), enabled: true, machineName: "Nueva Máquina", machinesCount: 1,
            hrsDay: 24, daysWeek: 5, weeksYear: 50, plannedDt: 60, unplannedDt: 30,
            parts: [] // Sub-niveles (Part Numbers)
        });
        saveAndSync();
    };

    window.addPartToMachine = (mId) => {
        const m = scData.find(x => x.id === mId);
        m.parts.push({ id: Date.now(), pn: "PN-001", annualQty: 100000, ct: 30, scrap: 2, pcsPerCycle: 1, coTime: 45, coFreq: 5 });
        saveAndSync();
    };

    function calculateShared() {
        scBody.innerHTML = '';
        scData.forEach((m, mIdx) => {
            const availMinDay = m.hrsDay * 60;
            let reqMinDay = 0;

            // Calcular requerimiento por cada Part Number
            m.parts.forEach(p => {
                const dailyQty = p.annualQty / (m.weeksYear * m.daysWeek);
                const yieldFactor = (100 - p.scrap) / 100;
                const runMin = ((dailyQty / yieldFactor) / p.pcsPerCycle) * (p.ct / 60);
                const coMin = p.coTime / p.coFreq;
                reqMinDay += (runMin + coMin);
            });

            const totalReq = reqMinDay + m.plannedDt + m.unplannedDt;
            const utilPercent = (totalReq / (availMinDay * m.machinesCount)) * 100;
            const color = utilPercent > 100 ? 'badge-bad' : (utilPercent > 90 ? 'badge-warn' : 'badge-good');

            // Render Máquina Principal
            scBody.innerHTML += `
                <tr style="background:rgba(0,0,0,0.05); font-weight:bold;">
                    <td><input type="checkbox" ${m.enabled?'checked':''} onchange="updateSc(${mIdx},'enabled',this.checked)"></td>
                    <td><input class="wb-inp wide" value="${m.machineName}" onchange="updateSc(${mIdx},'machineName',this.value)"></td>
                    <td><input class="wb-inp slim" type="number" value="${m.machinesCount}" onchange="updateSc(${mIdx},'machinesCount',this.value)"></td>
                    <td>${availMinDay}</td><td>${m.plannedDt}</td><td>${m.unplannedDt}</td>
                    <td>${m.daysWeek}</td><td>${m.weeksYear}</td>
                    <td>${totalReq.toFixed(1)}</td>
                    <td>${utilPercent.toFixed(1)}%</td>
                    <td><span class="badge ${color}">${utilPercent > 100 ? 'OVERLOAD' : 'OK'}</span></td>
                    <td><button class="wb-opbtn" onclick="syncToWb(${mIdx})">Sync ➔ WB</button></td>
                    <td><button class="wb-opbtn" onclick="addPartToMachine(${m.id})">+ PN</button></td>
                    <td><button class="btn-del" onclick="removeSc(${mIdx})">✖</button></td>
                </tr>`;

            // Render Sub-Partes
            m.parts.forEach((p, pIdx) => {
                scBody.innerHTML += `
                    <tr style="font-size: 0.65rem; color: #666;">
                        <td style="text-align:right;">└</td>
                        <td><input class="wb-inp" value="${p.pn}" onchange="updatePart(${mIdx},${pIdx},'pn',this.value)"></td>
                        <td colspan="2">Ann. Vol: <input class="wb-inp slim" type="number" value="${p.annualQty}" onchange="updatePart(${mIdx},${pIdx},'annualQty',this.value)"></td>
                        <td>CT: <input class="wb-inp slim" type="number" value="${p.ct}" onchange="updatePart(${mIdx},${pIdx},'ct',this.value)"></td>
                        <td>Scrap%: <input class="wb-inp slim" type="number" value="${p.scrap}" onchange="updatePart(${mIdx},${pIdx},'scrap',this.value)"></td>
                        <td>Pzs/Cyc: <input class="wb-inp slim" type="number" value="${p.pcsPerCycle}" onchange="updatePart(${mIdx},${pIdx},'pcsPerCycle',this.value)"></td>
                        <td>C/O: <input class="wb-inp slim" type="number" value="${p.coTime}" onchange="updatePart(${mIdx},${pIdx},'coTime',this.value)"></td>
                        <td colspan="4">Freq: <input class="wb-inp slim" type="number" value="${p.coFreq}" onchange="updatePart(${mIdx},${pIdx},'coFreq',this.value)"></td>
                        <td><button class="btn-del" onclick="removePart(${mIdx},${pIdx})">×</button></td>
                    </tr>`;
            });
        });
    }

    // --- SYNC SHARED ➔ WB ---
    window.syncToWb = (mIdx) => {
        const m = scData[mIdx];
        const reqMin = 0; // Calculado de sus partes
        // Buscamos si existe la operación en WB con el mismo nombre
        const targetWb = wbData.find(w => w.opName.toLowerCase() === m.machineName.toLowerCase());
        if(targetWb) {
            // Sumamos los minutos requeridos por los PN al campo 'shared' del WB
            let totalPartMin = 0;
            m.parts.forEach(p => {
                const dailyQty = p.annualQty / (m.weeksYear * m.daysWeek);
                totalPartMin += (dailyQty / ((100-p.scrap)/100) / p.pcsPerCycle) * (p.ct / 60) + (p.coTime/p.coFreq);
            });
            targetWb.shared = Math.round(totalPartMin);
            saveAndSync();
            alert(`Sincronizado: ${targetWb.shared} min/día cargados a ${targetWb.opName}`);
        } else {
            alert("No se encontró una operación en el Workbench con el nombre: " + m.machineName);
        }
    };

    // --- AUXILIARES SC ---
    window.updateSc = (idx, f, v) => { scData[idx][f] = (f==='enabled'||f==='machineName')?v:parseFloat(v); saveAndSync(); };
    window.removeSc = (idx) => { scData.splice(idx,1); saveAndSync(); };
    window.updatePart = (mIdx, pIdx, f, v) => { scData[mIdx].parts[pIdx][f] = (f==='pn')?v:parseFloat(v); saveAndSync(); };
    window.removePart = (mIdx, pIdx) => { scData[mIdx].parts.splice(pIdx,1); saveAndSync(); };

    // --- RE-INTEGRACIÓN WORKBENCH (PARTE 3) ---
    function renderWB() {
        wbBody.innerHTML = '';
        wbData.forEach((row, idx) => {
            const grossMin = row.shifts * row.hours * 60;
            const netMin = (grossMin - (row.lunch + row.changeover + row.cleaning + row.maint + row.other + row.shared) - row.unplannedDt) * row.machines;
            const capOee = (netMin * 60 / row.ctCur) * row.pcsPerOp;
            const vsContract = row.contract > 0 ? (capOee / row.contract) * 100 : 0;
            
            wbBody.innerHTML += `<tr>
                <td><input type="checkbox" ${row.enabled?'checked':''} onchange="updateWbField(${idx},'enabled',this.checked)"></td>
                <td><input class="wb-inp wide" value="${row.opName}" onchange="updateWbField(${idx},'opName',this.value)"></td>
                <td><input class="wb-inp slim" type="number" value="${row.operators}" onchange="updateWbField(${idx},'operators',this.value)"></td>
                <td><input class="wb-inp slim" type="number" value="${row.shifts}" onchange="updateWbField(${idx},'shifts',this.value)"></td>
                <td colspan="10">... (campos intermedios) ...</td>
                <td style="background:#fff3e0"><b>${row.shared}</b></td>
                <td>${netMin.toFixed(0)}</td>
                <td colspan="12"></td>
                <td class="${vsContract < 100 ? 'badge-bad' : 'badge-good'}">${vsContract.toFixed(1)}%</td>
                <td><button class="btn-del" onclick="removeWb(${idx})">✖</button></td>
            </tr>`;
        });
    }

    // --- GLOBAL SYNC ---
    function saveAndSync() {
        localStorage.setItem('taktlab_data', JSON.stringify(laps));
        localStorage.setItem('taktlab_wb', JSON.stringify(wbData));
        localStorage.setItem('taktlab_sc', JSON.stringify(scData));
        calculateShared();
        if(typeof renderWB === "function") renderWB();
        // Nota: renderRaw y renderFocus deben estar presentes de la P1/P2
    }

    saveAndSync();
})();
</script>
