<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TaktLab – Cycle Time & Capacity Analyzer</title>

<style>
  :root{
    --bg-main:#07152b;
    --bg-card:#0b1f3a;
    --bg-card-soft:#0f2544;
    --accent-green:#00c853;
    --accent-amber:#ffb300;
    --accent-red:#ff1744;
    --accent-blue:#29b6f6;
    --accent-grey:#cfd8dc;
    --text-main:#ffffff;
    --text-soft:#c5cae9;
    --text-muted:#90a4ae;
    --border-soft:#1c3357;
    --btn-green:#00c853;
    --btn-orange:#ff9100;
    --btn-grey:#455a64;
    --badge-green:#004d40;
    --badge-red:#b71c1c;
    --badge-amber:#ff8f00;
  }

  *{box-sizing:border-box;}

  body{
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 40%,#020b1a 100%);
    color:var(--text-main);
  }

  .page{
    max-width:1100px;
    margin:0 auto;
    padding:10px 10px 34px;
  }

  .sticky-timer-bar{
    position:sticky;
    top:0;
    z-index:100;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 90%);
    padding:6px 0 8px;
  }

  .top-row{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:6px;
  }

  .logo-circle{
    width:38px;height:38px;border-radius:50%;
    border:2px solid var(--accent-grey);
    display:flex;align-items:center;justify-content:center;
  }
  .logo-gear{
    width:22px;height:22px;border-radius:50%;
    border:2px solid var(--accent-grey);
    position:relative;
  }
  .logo-gear::before{
    content:"";
    position:absolute;
    inset:4px;
    border-radius:50%;
    border:2px solid var(--accent-green);
    border-right-color:transparent;
    border-bottom-color:transparent;
    transform-origin:50% 50%;
  }
  .logo-gear.spinning::before{ animation:logo-spin 2s linear infinite; }
  @keyframes logo-spin{ from{transform:rotate(0deg);} to{transform:rotate(360deg);} }

  .title-block{display:flex;flex-direction:column;gap:2px;}
  .title-main{font-size:1.2rem;font-weight:700;letter-spacing:.03em;}
  .title-sub{font-size:.72rem;color:var(--text-soft);}

  .lang-switch{margin-left:auto;display:flex;align-items:center;gap:4px;}
  .lang-btn{
    border-radius:999px;border:1px solid var(--border-soft);
    background:rgba(2,11,26,.6);color:var(--text-soft);
    font-size:.7rem;padding:4px 8px;cursor:pointer;min-width:34px;
  }
  .lang-btn.active{background:var(--accent-blue);color:#fff;border-color:var(--accent-blue);font-weight:600;}

  .timer-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:6px 10px 10px;
    box-shadow:0 8px 18px rgba(0,0,0,.45);
  }

  .timer-display{
    text-align:center;
    font-size:2.8rem;
    font-weight:600;
    letter-spacing:.08em;
    padding:4px 4px 6px;
  }

  .info-stack{ display:flex; flex-direction:column; gap:6px; margin:0 0 8px; }
  .info-line{
    font-size:.78rem;margin:0;padding:6px 10px;
    border-radius:12px;border:1px solid transparent;
    line-height:1.25;
  }
  .sample-neutral{background:rgba(255,255,255,.03);border-color:rgba(255,255,255,.08);color:var(--text-soft);}
  .sample-good{background:rgba(0,200,83,.15);border-color:rgba(0,200,83,.7);color:#c8e6c9;}
  .sample-warn{background:rgba(255,193,7,.14);border-color:rgba(255,193,7,.8);color:#ffe082;}
  .sample-bad{background:rgba(244,67,54,.16);border-color:rgba(244,67,54,.9);color:#ffab91;}

  .btn-row-main{display:flex;gap:10px;margin-bottom:2px;}
  .btn{
    border:none;border-radius:16px;padding:10px 12px;
    font-size:.9rem;font-weight:600;cursor:pointer;color:#fff;
    box-shadow:0 4px 10px rgba(0,0,0,.4);flex:1;
    transition:transform .04s ease, box-shadow .04s ease, background .15s;
    touch-action:manipulation;
  }
  .btn:active{transform:translateY(1px);box-shadow:0 1px 4px rgba(0,0,0,.5);}
  .btn-start{background:var(--btn-green);}
  .btn-lap{background:var(--btn-orange);}

  .flash{animation:flash-bg .12s ease-out;}
  @keyframes flash-bg{ from{background:rgba(255,255,255,.18);} to{background:transparent;} }

  .content-section{margin-top:8px;}

  .section-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:8px 10px 10px;
    margin-bottom:10px;
  }
  .section-title{font-size:1.0rem;font-weight:700;margin-bottom:6px;}

  .mode-row{
    display:flex;gap:8px;flex-wrap:wrap;align-items:flex-end;
    font-size:.78rem;color:var(--text-soft);
  }
  .mode-row select,.mode-row input{
    background:#020b1a;border-radius:8px;border:1px solid var(--border-soft);
    padding:4px 8px;color:var(--text-soft);font-size:.78rem;min-width:70px;
  }
  .mode-row input[type="number"]{width:78px;}

  table{width:100%;border-collapse:collapse;font-size:.72rem;}
  th,td{
    padding:3px 5px;text-align:right;
    border-bottom:1px solid rgba(255,255,255,.04);
    white-space:nowrap;
    vertical-align:middle;
  }
  th:first-child,td:first-child{text-align:left;}
  th{
    color:var(--text-soft);font-weight:600;background:rgba(255,255,255,.02);
    position:sticky;top:0;z-index:5;
  }
  tbody tr:nth-child(even){background:rgba(255,255,255,.02);}

  .badge{
    display:inline-block;padding:2px 6px;border-radius:999px;
    font-size:.68rem;border:1px solid transparent;
  }
  .badge-good{background:var(--badge-green);border-color:#00e676;}
  .badge-warn{background:var(--badge-amber);border-color:#ffe082;color:#000;}
  .badge-bad{background:var(--badge-red);border-color:#ff8a80;}

  .btn-row-secondary{display:flex;flex-wrap:wrap;gap:10px;margin:8px 0 4px;}
  .btn-small{
    padding:12px 18px;
    border-radius:18px;
    font-size:.95rem;
    font-weight:800;
    flex:0 0 auto;background:var(--bg-card-soft);color:var(--text-soft);
    border:1px solid var(--border-soft);cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,.35);
  }
  .btn-small-copy{background:var(--accent-blue);border-color:var(--accent-blue);color:#fff;}
  .btn-small-summary{background:var(--accent-amber);border-color:var(--accent-amber);color:#000;}
  .btn-small-manual{background:var(--accent-green);border-color:var(--accent-green);color:#000;}
  .btn-small-reset{background:var(--accent-red);border-color:var(--accent-red);color:#fff;}
  .btn-small-wbadd{background:rgba(255,255,255,.06);color:var(--text-soft);}
  .btn-small-wbclear{background:rgba(255,23,68,.16);border-color:rgba(255,23,68,.6);color:#ff8a80;}

  .subsection-title{margin-top:10px;font-size:.82rem;font-weight:650;color:var(--text-soft);}

  .footer-note{margin-top:10px;font-size:.65rem;color:var(--text-muted);text-align:right;}

  .charts-wrapper{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:10px;
  }
  .chart-card{
    background:var(--bg-card-soft);
    border-radius:14px;
    border:1px solid var(--border-soft);
    padding:8px;
  }
  .chart-title{font-size:.75rem;margin-bottom:4px;color:var(--text-soft);}
  canvas{width:100%;height:180px;background:#020b1a;border-radius:10px;}

  .btn-edit,.btn-del,.btn-relink{
    padding:2px 6px;border-radius:8px;font-size:.7rem;
    border:1px solid rgba(255,255,255,.2);cursor:pointer;background:transparent;
  }
  .btn-edit{color:#81d4fa;}
  .btn-del{color:#ff8a80;}
  .btn-relink{color:#ffe082;}

  .wb-inp, .wb-sel, .wb-chk{
    background:#020b1a;border-radius:8px;border:1px solid var(--border-soft);
    padding:2px 5px;color:var(--text-soft);font-size:.70rem;
  }
  .wb-inp{width:72px;}
  .wb-inp.wide{width:140px;}
  .wb-inp.slim{width:56px;}
  .wb-sel{width:84px;}
  .wb-pill{
    display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.03);font-size:.72rem;color:var(--text-soft);
  }
  .wb-alert{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px;}
  .wb-alert .badge{font-size:.72rem;padding:4px 10px;}
  .wb-badge-title{font-size:.72rem;color:var(--text-soft);}
  .wb-mini{font-size:.7rem;color:var(--text-muted);line-height:1.25;margin-top:6px;}
  .wb-sumline{
    display:flex;justify-content:flex-end;gap:10px;align-items:center;
    margin-top:6px;font-size:.72rem;color:var(--text-soft);
  }
  .wb-sumline .badge{font-size:.70rem}

  /* =========================
     ✅ WB STICKY COLUMNS (Seq, On, Operation)
     ========================= */
  #wbTable{ border-collapse:separate; border-spacing:0; }
  #wbTable th, #wbTable td{ position:relative; }
  /* 1st col: Seq */
  #wbTable th:nth-child(1), #wbTable td:nth-child(1){
    position:sticky; left:0;
    z-index:30;
    background:linear-gradient(180deg, rgba(2,11,26,.98) 0%, rgba(7,21,43,.98) 100%);
  }
  /* 2nd col: On */
  #wbTable th:nth-child(2), #wbTable td:nth-child(2){
    position:sticky; left:62px;
    z-index:30;
    background:linear-gradient(180deg, rgba(2,11,26,.98) 0%, rgba(7,21,43,.98) 100%);
  }
  /* 3rd col: Operation */
  #wbTable th:nth-child(3), #wbTable td:nth-child(3){
    position:sticky; left:112px;
    z-index:30;
    background:linear-gradient(180deg, rgba(2,11,26,.98) 0%, rgba(7,21,43,.98) 100%);
  }
  /* Make header a bit higher priority */
  #wbTable thead th:nth-child(1),
  #wbTable thead th:nth-child(2),
  #wbTable thead th:nth-child(3){
    z-index:40;
  }

  @media (max-width:600px){
    .timer-display{font-size:2.2rem;}
    .btn-row-main{gap:6px;}
    .btn{font-size:.9rem;border-radius:14px;}
    canvas{height:160px;}
    th,td{font-size:.70rem;}
    .wb-inp{width:66px;}
    .wb-inp.wide{width:120px;}
    .btn-small{padding:12px 16px;font-size:.92rem;}
    /* small screens sticky offsets */
    #wbTable th:nth-child(2), #wbTable td:nth-child(2){ left:58px; }
    #wbTable th:nth-child(3), #wbTable td:nth-child(3){ left:106px; }
  }
</style>
</head>

<body>
<div class="page">

  <div class="sticky-timer-bar">
    <div class="top-row">
      <div class="logo-circle"><div class="logo-gear" id="logoGear"></div></div>
      <div class="title-block">
        <div class="title-main">TaktLab</div>
        <div class="title-sub" data-i18n="title.subtitle">Cycle Time &amp; Capacity Analyzer</div>
      </div>
      <div class="lang-switch">
        <button class="lang-btn" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="es">ES</button>
      </div>
    </div>

    <div class="timer-card" id="timerCard">
      <div class="timer-display" id="display">00:00.00</div>

      <div class="info-stack">
        <div class="info-line sample-neutral" id="sampleInfoTop">
          No samples yet for current process. Start capturing laps.
        </div>
      </div>

      <div class="btn-row-main">
        <button class="btn btn-start" id="btnStart" data-i18n="btn.start">Start</button>
        <button class="btn btn-lap" id="btnLap" data-i18n="btn.lap">LAP</button>
      </div>
    </div>
  </div>

  <div class="content-section">

    <div class="section-card">
      <div class="section-title" data-i18n="section.measurementSetup">Measurement Setup</div>

      <div class="mode-row">
        <div>
          <label for="processName" data-i18n="label.process">Process</label><br/>
          <input id="processName" type="text" placeholder="e.g. Op 30-1" data-i18n-placeholder="label.processPlaceholder"/>
        </div>

        <div>
          <label for="mode" data-i18n="label.mode">Mode</label><br/>
          <select id="mode">
            <option value="CT" data-i18n="mode.ct">Cycle Time (CT)</option>
            <option value="MLD" data-i18n="mode.mld">Machine &amp; Load/Unload</option>
          </select>
        </div>

        <div>
          <label for="efficiency" data-i18n="label.efficiency">Efficiency %</label><br/>
          <input id="efficiency" type="number" value="100" min="0" max="100" step="1"/>
        </div>

        <div>
          <label for="contractPcd" data-i18n="label.contractPcd">Contract Cap (pcs/day)</label><br/>
          <input id="contractPcd" type="number" min="0" max="99999" step="1"/>
        </div>

        <div>
          <label for="hoursPerDay" data-i18n="label.hoursPerDay">Hours / Day</label><br/>
          <input id="hoursPerDay" type="number" value="8" min="1" max="24" step=".5"/>
        </div>

        <div>
          <label for="daysPerWeek" data-i18n="label.daysPerWeek">Days / Week</label><br/>
          <input id="daysPerWeek" type="number" value="5" min="1" max="7"/>
        </div>

        <div>
          <label for="capView" data-i18n="label.capView">Capacity View</label><br/>
          <select id="capView">
            <option value="hour" data-i18n="capView.hour">per Hour</option>
            <option value="day" data-i18n="capView.day">per Day</option>
            <option value="week" data-i18n="capView.week">per Week</option>
          </select>
        </div>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.contractSummary">Contract vs Capacity Summary</div>

      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="contractSumLine1">—</div>
        <div class="info-line sample-neutral" id="contractSumLine2">—</div>
        <div class="info-line sample-neutral" id="contractSumLine3">—</div>
        <div class="info-line sample-neutral" id="contractSumLine4">—</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 0;">
        <span data-i18n="contract.note">Uses current process + your laps (Median/P10/P90) with the Measurement Setup assumptions.</span>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.statsFocus">Stat Focus</div>

      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="sampleInfoFocus">Sample size: —</div>
        <div class="info-line sample-neutral" id="stdInfoFocus">Std dev: —</div>
        <div class="info-line sample-neutral" id="distInfoFocus">Mean vs Median: —</div>
        <div class="info-line sample-neutral" id="contractInfoFocus">No contract loaded</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 6px;">
        <span data-i18n="stats.note">Simple language on purpose: few / enough samples, low / high variation, capable / not capable.</span>
      </div>

      <div style="max-height:300px;overflow:auto;">
        <table>
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th>N</th>
              <th data-i18n="col.sample">Sample size / Error</th>
              <th>Std</th>
              <th>CV%</th>
              <th>CTmed</th>
              <th>P10</th>
              <th>P90</th>
              <th data-i18n="col.capCurrent">Current @Eff</th>
              <th data-i18n="col.capPotential">Potential @Eff</th>
              <th data-i18n="col.capWorst">Worst @Eff</th>
              <th data-i18n="col.contract">Contract</th>
              <th data-i18n="col.gap">Gap</th>
              <th data-i18n="col.vsContract">% vs</th>
              <th>Cp</th>
              <th>Cpk</th>
              <th data-i18n="col.note">Note</th>
            </tr>
          </thead>
          <tbody id="focusBody"></tbody>
        </table>
      </div>

      <div class="subsection-title" data-i18n="section.wbPlanner">WB – Capacity Planner (by process)</div>

      <div class="btn-row-secondary" style="margin-top:8px;">
        <button class="btn-small btn-small-wbadd" id="btnWbAdd" data-i18n="btn.wbAdd">+ Add Operation</button>
        <button class="btn-small btn-small-wbclear" id="btnWbClear" data-i18n="btn.wbClear">Clear WB</button>
      </div>

      <div style="max-height:320px;overflow:auto;">
        <table id="wbTable">
          <thead>
            <tr>
              <th data-i18n="wb.seq">Seq</th>
              <th data-i18n="wb.enabled">On</th>
              <th data-i18n="wb.operation">Operation</th>
              <th data-i18n="wb.operators">Operators</th>
              <th data-i18n="wb.shifts">Shifts</th>
              <th data-i18n="wb.hours">Hours</th>
              <th data-i18n="wb.machines"># Machines</th>
              <th data-i18n="wb.contract">Contract (pcs/day)</th>

              <th data-i18n="wb.gross">Gross min/day</th>
              <th data-i18n="wb.lunch">Lunch min/day</th>
              <th data-i18n="wb.changeover">Changeover</th>
              <th data-i18n="wb.cleaning">5S/Clean</th>
              <th data-i18n="wb.maint">Maintenance</th>
              <th data-i18n="wb.other">Other</th>

              <th data-i18n="wb.shared">Shared Capacity</th>

              <th data-i18n="wb.udt">Unplanned DT</th>
              <th data-i18n="wb.udtUnit">Unit</th>

              <th data-i18n="wb.net">Net min/day</th>

              <th data-i18n="wb.scrap">Scrap %</th>
              <th data-i18n="wb.yield">Yield</th>

              <th data-i18n="wb.oeeA">A%</th>
              <th data-i18n="wb.oeeP">P%</th>
              <th data-i18n="wb.oeeQ">Q%</th>
              <th data-i18n="wb.oee">OEE%</th>

              <th data-i18n="wb.ctCur">CT Current</th>
              <th data-i18n="wb.ctWst">CT Worst</th>
              <th data-i18n="wb.ctPot">CT Potential</th>

              <th data-i18n="wb.ctCurOee">CT@OEE (Cur)</th>

              <th data-i18n="wb.cap100">Cap 100% (Cur)</th>
              <th data-i18n="wb.capOee">Cap@OEE (Cur)</th>

              <th data-i18n="wb.vsContract">% vs contract</th>
              <th data-i18n="wb.inputReq">Input req. for Contract</th>

              <th data-i18n="wb.actions">Actions</th>
            </tr>
          </thead>
          <tbody id="wbBody"></tbody>
        </table>
      </div>

      <div class="wb-sumline">
        <span data-i18n="wb.opsSum">Operators total:</span>
        <span class="badge badge-warn" id="wbOperatorsSum">0</span>
      </div>

      <div class="wb-alert">
        <span class="wb-badge-title" data-i18n="wb.constraintTitle">Constraint / Next:</span>
        <span class="badge badge-bad" id="wbConstraint">—</span>
        <span class="badge badge-warn" id="wbNextConstraint">—</span>
      </div>
      <div class="wb-mini" id="wbConstraintNote"></div>

      <div class="subsection-title" data-i18n="section.statsDetail">Statistical Detail (per process)</div>
      <div style="max-height:240px;overflow:auto;">
        <table id="statsTable">
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.n">N</th>
              <th>Mean</th>
              <th>Median</th>
              <th>P10</th>
              <th>P90</th>
              <th>Min</th>
              <th>Max</th>
              <th>Std</th>
              <th>CV%</th>
              <th>Cp</th>
              <th>Cpk</th>
            </tr>
          </thead>
          <tbody id="statsBody"></tbody>
        </table>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.dataControls">Data Controls</div>
      <div class="btn-row-secondary">
        <button class="btn-small btn-small-copy" id="btnCopyAll" data-i18n="btn.copyAll">Copy All</button>
        <button class="btn-small btn-small-summary" id="btnCopySummary" data-i18n="btn.copySummary">Copy Summary</button>
        <button class="btn-small btn-small-manual" id="btnAddManualLap" data-i18n="btn.addManualLap">Add Manual Lap</button>
        <button class="btn-small btn-small-reset" id="btnReset" data-i18n="btn.reset">Reset</button>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.charts">Charts (selected process)</div>

      <div style="margin-bottom:6px;font-size:.75rem;">
        <label for="chartProcessSelect" data-i18n="label.chartProcessLabel">Process / Mode:</label>
        <select id="chartProcessSelect"></select>
      </div>

      <div class="charts-wrapper">
        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.timeSeriesTitle">Time Series with Mean, Median, ±3σ</div>
          <canvas id="timeSeriesCanvas"></canvas>
        </div>

        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.histTitle">Histogram with Median &amp; Percentiles</div>
          <canvas id="histCanvas"></canvas>
        </div>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.rawData">Raw Time Data</div>
      <div style="max-height:300px;overflow:auto;">
        <table id="dataTable">
          <thead>
            <tr>
              <th data-i18n="col.index">#</th>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.status">Status</th>
              <th data-i18n="col.note">Note</th>
              <th data-i18n="col.t1">T1 (s)</th>
              <th data-i18n="col.t2">T2 (s)</th>
              <th data-i18n="col.total">Total (s)</th>
              <th data-i18n="col.edit">Edit</th>
              <th data-i18n="col.del">Del</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.methodGuide">Method &amp; Guide</div>
      <details style="background:var(--bg-card-soft);border:1px solid var(--border-soft);border-radius:14px;padding:10px;">
        <summary style="cursor:pointer;color:var(--text-soft);font-weight:700;">
          <span data-i18n="method.open">Open</span>
        </summary>
        <div style="margin-top:8px;font-size:.72rem;color:var(--text-soft);line-height:1.35;white-space:pre-wrap;" id="methodGuideText"></div>
      </details>
    </div>

  </div>

  <div class="footer-note" data-i18n="footer.note">
    Created by Roberto González – Contact: hzaelglez@gmail.com
  </div>
</div>

<script>
(function(){
  const display = document.getElementById('display');
  const btnStart = document.getElementById('btnStart');
  const btnLap = document.getElementById('btnLap');
  const timerCard = document.getElementById('timerCard');
  const logoGear = document.getElementById('logoGear');

  const sampleInfoTop = document.getElementById('sampleInfoTop');
  const sampleInfoFocus = document.getElementById('sampleInfoFocus');
  const stdInfoFocus = document.getElementById('stdInfoFocus');
  const distInfoFocus = document.getElementById('distInfoFocus');
  const contractInfoFocus = document.getElementById('contractInfoFocus');

  const contractSumLine1 = document.getElementById('contractSumLine1');
  const contractSumLine2 = document.getElementById('contractSumLine2');
  const contractSumLine3 = document.getElementById('contractSumLine3');
  const contractSumLine4 = document.getElementById('contractSumLine4');

  const processInput = document.getElementById('processName');
  const modeSelect   = document.getElementById('mode');
  const effInput     = document.getElementById('efficiency');
  const pcdInput     = document.getElementById('contractPcd');
  const hInput       = document.getElementById('hoursPerDay');
  const dInput       = document.getElementById('daysPerWeek');
  const capViewSel   = document.getElementById('capView');

  const focusBody     = document.getElementById('focusBody');
  const statsBody     = document.getElementById('statsBody');

  const dataBody    = document.getElementById('dataBody');
  const btnCopyAll  = document.getElementById('btnCopyAll');
  const btnCopySum  = document.getElementById('btnCopySummary');
  const btnAddMan   = document.getElementById('btnAddManualLap');
  const btnReset    = document.getElementById('btnReset');

  const chartSelect      = document.getElementById('chartProcessSelect');
  const timeSeriesCanvas = document.getElementById('timeSeriesCanvas');
  const histCanvas       = document.getElementById('histCanvas');

  const langButtons = document.querySelectorAll('.lang-btn');

  const wbBody = document.getElementById('wbBody');
  const btnWbAdd = document.getElementById('btnWbAdd');
  const btnWbClear = document.getElementById('btnWbClear');
  const wbConstraint = document.getElementById('wbConstraint');
  const wbNextConstraint = document.getElementById('wbNextConstraint');
  const wbConstraintNote = document.getElementById('wbConstraintNote');
  const wbOperatorsSum = document.getElementById('wbOperatorsSum');
  const methodGuideText = document.getElementById('methodGuideText');

  /* ============================
     ✅ Formatting (MAX 2 decimals)
     ============================ */
  function formatSecs(s){
    if(!isFinite(s)) return '-';
    return (Math.round(s*100)/100).toFixed(2);
  }
  function formatTime(ms){
    const total=Math.max(ms,0);
    const mins=Math.floor(total/60000);
    const secs=Math.floor((total%60000)/1000);
    const cent=Math.floor((total%1000)/10);
    return (mins<10?'0'+mins:mins)+':'+(secs<10?'0'+secs:secs)+'.'+(cent<10?'0'+cent:cent);
  }
  function formatUnits(n){
    if(!isFinite(n)) return '-';
    const rounded=Math.round(n);
    return rounded.toLocaleString('en-US',{maximumFractionDigits:0});
  }
  function pct(n, digits=0){ if(!isFinite(n)) return '-'; return n.toFixed(digits)+'%'; }

  /* ============================
     ✅ Normalize operation names (WB runaway rows fix)
     ============================ */
  function normOp(s){
    return (s||'')
      .toString()
      .trim()
      .replace(/\s+/g,' ')
      .toLowerCase();
  }

  const i18n = {
    en:{
      'title.subtitle':'Cycle Time & Capacity Analyzer',
      'btn.start':'Start','btn.pause':'Pause','btn.lap':'LAP',
      'btn.copyAll':'Copy All','btn.copySummary':'Copy Summary','btn.addManualLap':'Add Manual Lap','btn.reset':'Reset',
      'section.measurementSetup':'Measurement Setup',
      'section.contractSummary':'Contract vs Capacity Summary',
      'contract.note':'Uses current process + your laps (Median/P10/P90) with the Measurement Setup assumptions.',
      'section.statsFocus':'Stat Focus',
      'section.dataControls':'Data Controls',
      'section.rawData':'Raw Time Data',
      'section.charts':'Charts (selected process)',
      'section.statsDetail':'Statistical Detail (per process)',
      'section.wbPlanner':'WB – Capacity Planner (by process)',
      'section.methodGuide':'Method & Guide',
      'method.open':'Open',

      'label.process':'Process','label.processPlaceholder':'e.g. Op 30-1',
      'label.mode':'Mode','label.efficiency':'Efficiency %','label.contractPcd':'Contract Cap (pcs/day)',
      'label.hoursPerDay':'Hours / Day','label.daysPerWeek':'Days / Week','label.capView':'Capacity View',
      'label.chartProcessLabel':'Process / Mode:',

      'mode.ct':'Cycle Time (CT)','mode.mld':'Machine & Load/Unload',
      'capView.hour':'per Hour','capView.day':'per Day','capView.week':'per Week',

      'col.index':'#','col.process':'Process','col.mode':'Mode','col.status':'Status','col.note':'Note',
      'col.t1':'T1 (s)','col.t2':'T2 (s)','col.total':'Total (s)','col.edit':'Edit','col.del':'Del','col.n':'N',
      'col.sample':'Sample size / Error',
      'col.capCurrent':'Current @Eff','col.capPotential':'Potential @Eff','col.capWorst':'Worst @Eff',
      'col.contract':'Contract','col.gap':'Gap','col.vsContract':'% vs',
      'chart.timeSeriesTitle':'Time Series with Mean, Median, ±3σ',
      'chart.histTitle':'Histogram with Median & Percentiles',
      'stats.note':'Simple language on purpose: few / enough samples, low / high variation, capable / not capable.',
      'footer.note':'Created by Roberto González – Contact: hzaelglez@gmail.com',

      'btn.wbAdd':'+ Add Operation',
      'btn.wbClear':'Clear WB',
      'wb.seq':'Seq',
      'wb.enabled':'On',
      'wb.operation':'Operation',
      'wb.operators':'Operators',
      'wb.shifts':'Shifts',
      'wb.hours':'Hours',
      'wb.machines':'# Machines',
      'wb.contract':'Contract (pcs/day)',
      'wb.gross':'Gross min/day',
      'wb.lunch':'Lunch min/day',
      'wb.changeover':'Changeover (min/day)',
      'wb.cleaning':'5S/Clean (min/day)',
      'wb.maint':'Maintenance (min/day)',
      'wb.other':'Other (min/day)',
      'wb.shared':'Shared Capacity (min/day)',
      'wb.udt':'Unplanned DT',
      'wb.udtUnit':'Unit',
      'wb.net':'Net min/day',
      'wb.scrap':'Scrap %',
      'wb.yield':'Yield',
      'wb.oeeA':'A%',
      'wb.oeeP':'P%',
      'wb.oeeQ':'Q%',
      'wb.oee':'OEE%',
      'wb.ctCur':'CT Current (s)',
      'wb.ctWst':'CT Worst (s)',
      'wb.ctPot':'CT Potential (s)',
      'wb.ctCurOee':'CT@OEE (Cur)',
      'wb.cap100':'Cap 100% (Cur/day)',
      'wb.capOee':'Cap@OEE (Cur/day)',
      'wb.vsContract':'% vs contract',
      'wb.inputReq':'Input req. for Contract',
      'wb.actions':'Actions',
      'wb.constraintTitle':'Constraint / Next:',
      'wb.opsSum':'Operators total:'
    },
    es:{
      'title.subtitle':'Analizador de Tiempo de Ciclo y Capacidad',
      'btn.start':'Iniciar','btn.pause':'Pausar','btn.lap':'VUELTA',
      'btn.copyAll':'Copiar todo','btn.copySummary':'Copiar resumen','btn.addManualLap':'Agregar vuelta manual','btn.reset':'Reiniciar',
      'section.measurementSetup':'Configuración de Medición',
      'section.contractSummary':'Resumen Contrato vs Capacidad',
      'contract.note':'Usa el proceso actual + tus vueltas (Mediana/P10/P90) con los supuestos de Measurement Setup.',
      'section.statsFocus':'Enfoque Estadístico',
      'section.dataControls':'Controles de Datos',
      'section.rawData':'Datos Crudos de Tiempo',
      'section.charts':'Gráficas (proceso seleccionado)',
      'section.statsDetail':'Detalle Estadístico (por proceso)',
      'section.wbPlanner':'WB – Planeador de Capacidad (por proceso)',
      'section.methodGuide':'Método & Guía',
      'method.open':'Abrir',

      'label.process':'Proceso','label.processPlaceholder':'p. ej. Op 30-1',
      'label.mode':'Modo','label.efficiency':'Eficiencia %','label.contractPcd':'Capacidad contrato (pzs/día)',
      'label.hoursPerDay':'Horas / día','label.daysPerWeek':'Días / semana','label.capView':'Vista de capacidad',
      'label.chartProcessLabel':'Proceso / Modo:',

      'mode.ct':'Tiempo de ciclo (CT)','mode.mld':'Máquina y Carga/Descarga',
      'capView.hour':'por hora','capView.day':'por día','capView.week':'por semana',

      'col.index':'#','col.process':'Proceso','col.mode':'Modo','col.status':'Estatus','col.note':'Nota',
      'col.t1':'T1 (s)','col.t2':'T2 (s)','col.total':'Total (s)','col.edit':'Editar','col.del':'Borrar','col.n':'N',
      'col.sample':'Tamaño de muestra / Error',
      'col.capCurrent':'Actual @Eff','col.capPotential':'Potencial @Eff','col.capWorst':'Peor @Eff',
      'col.contract':'Contrato','col.gap':'Gap','col.vsContract':'% vs',
      'chart.timeSeriesTitle':'Serie de tiempo con media, mediana y ±3σ',
      'chart.histTitle':'Histograma con mediana y percentiles',
      'stats.note':'Lenguaje simple: pocas / suficientes muestras, baja / alta variación, capaz / no capaz.',
      'footer.note':'Creado por Roberto González – Contacto: hzaelglez@gmail.com',

      'btn.wbAdd':'+ Agregar operación',
      'btn.wbClear':'Borrar WB',
      'wb.seq':'Orden',
      'wb.enabled':'On',
      'wb.operation':'Operación',
      'wb.operators':'Operadores',
      'wb.shifts':'Turnos',
      'wb.hours':'Horas',
      'wb.machines':'# Máquinas',
      'wb.contract':'Contrato (pzs/día)',
      'wb.gross':'Min brutos/día',
      'wb.lunch':'Comida/día',
      'wb.changeover':'Changeover (min/día)',
      'wb.cleaning':'5S/Limpieza (min/día)',
      'wb.maint':'Mtto (min/día)',
      'wb.other':'Otros (min/día)',
      'wb.shared':'Capacidad compartida (min/día)',
      'wb.udt':'DT no planeado',
      'wb.udtUnit':'Unidad',
      'wb.net':'Min netos/día',
      'wb.scrap':'Scrap %',
      'wb.yield':'Yield',
      'wb.oeeA':'Disp%',
      'wb.oeeP':'Rend%',
      'wb.oeeQ':'Calidad%',
      'wb.oee':'OEE%',
      'wb.ctCur':'CT Actual (s)',
      'wb.ctWst':'CT Peor (s)',
      'wb.ctPot':'CT Potencial (s)',
      'wb.ctCurOee':'CT@OEE (Act)',
      'wb.cap100':'Cap 100% (Act/día)',
      'wb.capOee':'Cap@OEE (Act/día)',
      'wb.vsContract':'% vs contrato',
      'wb.inputReq':'Entrada req. p/Contrato',
      'wb.actions':'Acciones',
      'wb.constraintTitle':'Restricción / Siguiente:',
      'wb.opsSum':'Operadores total:'
    }
  };

  let currentLang = localStorage.getItem('taktlabLang') || 'en';
  function t(key){ return (i18n[currentLang] && i18n[currentLang][key]) || i18n.en[key] || key; }

  function applyTranslations(){
    document.querySelectorAll('[data-i18n]').forEach(el=>{
      const key = el.dataset.i18n;
      if(el === btnStart) return;
      el.textContent = t(key);
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el=>{
      const key = el.dataset.i18nPlaceholder;
      el.placeholder = t(key);
    });
  }
  function updateLangButtons(){ langButtons.forEach(b=>b.classList.toggle('active', b.dataset.lang === currentLang)); }
  function setLanguage(lang){
    currentLang = (lang==='es') ? 'es' : 'en';
    localStorage.setItem('taktlabLang', currentLang);
    document.documentElement.lang = currentLang;
    updateLangButtons();
    applyTranslations();
    btnStart.textContent = running ? t('btn.pause') : t('btn.start');
    renderAll();
  }
  langButtons.forEach(btn=>btn.addEventListener('click',()=>setLanguage(btn.dataset.lang)));

  const WB_KEY = 'taktlabWB_v2_sync';

  function clamp(n,min,max){ n = isFinite(n)?n:0; return Math.min(Math.max(n,min),max); }

  let running=false, startTime=0, elapsed=0, timerId=null;
  let laps=[], nextId=1;
  let pendingT1=null;

  function updateDisplay(){ display.textContent = formatTime(elapsed); }
  function refreshRingStates(){
    if(!running){ logoGear.classList.remove('spinning'); return; }
    logoGear.classList.add('spinning');
  }
  function tick(){
    const now=performance.now();
    elapsed=now-startTime;
    updateDisplay();
    timerId=requestAnimationFrame(tick);
  }
  function start(){
    if(running) return;
    running=true;
    startTime=performance.now()-elapsed;
    timerId=requestAnimationFrame(tick);
    btnStart.textContent=t('btn.pause');
    refreshRingStates();
  }
  function pause(){
    if(!running) return;
    running=false;
    cancelAnimationFrame(timerId);
    timerId=null;
    btnStart.textContent=t('btn.start');
    refreshRingStates();
  }
  btnStart.addEventListener('click',()=>{ running?pause():start(); });

  function flashCard(){ timerCard.classList.add('flash'); setTimeout(()=>timerCard.classList.remove('flash'),120); }
  function vibrate(ms=18){ try{ if(navigator.vibrate) navigator.vibrate(ms); }catch(e){} }

  function ensureDefaults(){
    let proc=(processInput.value||'').trim();
    if(!proc){
      proc = currentLang==='es' ? 'Proceso 1' : 'Process 1';
      processInput.value=proc;
    }
    let mode=modeSelect.value||'CT';
    modeSelect.value=mode;
    return {proc,mode};
  }

  function groupByProcess(){
    const map=new Map();
    laps.forEach(l=>{
      const key=l.process+'||'+l.mode;
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push(l);
    });
    return map;
  }

  function percentile(values,p){
    const n=values.length;
    if(n===0) return NaN;
    if(n===1) return values[0];
    const idx=(n-1)*p;
    const lo=Math.floor(idx), hi=Math.ceil(idx);
    if(lo===hi) return values[lo];
    return values[lo]+(values[hi]-values[lo])*(idx-lo);
  }

  function calcStats(arr){
    if(!arr.length) return null;
    const values=arr.map(x=>x.total).slice().sort((a,b)=>a-b);
    const n=values.length;
    const mean=values.reduce((s,v)=>s+v,0)/n;
    const median=n%2?values[(n-1)/2]:(values[n/2-1]+values[n/2])/2;
    const min=values[0], max=values[n-1];
    const variance=values.reduce((s,v)=>s+Math.pow(v-mean,2),0)/(n-1||1);
    const std=Math.sqrt(variance);
    const p10=percentile(values,0.1);
    const p90=percentile(values,0.9);
    const cv=mean?std/mean:0;
    return {n,values,mean,median,min,max,std,p10,p90,cv};
  }

  function capFromCt(ctSeconds, view, hours, days){
    if(!ctSeconds || ctSeconds<=0) return 0;
    const perHour=3600/ctSeconds;
    if(view==='hour') return perHour;
    if(view==='day') return perHour*hours;
    return perHour*hours*days;
  }
  function contractUnitsFromPcd(pcd, view, hours, days){
    if(!pcd || pcd<=0) return 0;
    if(view==='hour') return (pcd/hours)||0;
    if(view==='day') return pcd;
    return pcd*days;
  }

  function sampleReqN(cv){
    const Z=1.96, targetError=0.03;
    if(!isFinite(cv) || cv<=0) return 10;
    let n = Math.ceil(Math.pow((Z*cv)/targetError,2));
    if(n<10) n=10;
    return n;
  }
  function estErrorPct(cv,n){
    const Z=1.96;
    if(!isFinite(cv) || cv<=0 || n<=0) return 0;
    return (Z*cv)/Math.sqrt(n)*100;
  }

  function setInfo(div, cls, text){
    div.className = 'info-line ' + cls;
    div.textContent = text;
  }

  function buildSampleLine(st){
    if(!st || st.n<3){
      return {
        cls:'sample-neutral',
        text:(currentLang==='es'
          ? `Tamaño de muestra: ${st?st.n:0} / 3 – se requieren ≥3 vueltas antes de estimar el error.`
          : `Sample size: ${st?st.n:0} / 3 – need ≥3 laps before estimating error.`
        )
      };
    }
    const n=st.n;
    const cv=st.cv||0;
    const recN = sampleReqN(cv);
    const errPct = estErrorPct(cv,n);
    const ratio=n/recN;

    let cls='sample-warn', tail='';
    if(ratio<0.6){
      cls='sample-bad';
      tail = currentLang==='es'
        ? 'Muestra muy pequeña para ±3% – úsala solo como referencia.'
        : 'Sample too small for ±3% – use only as reference.';
    }else if(ratio<0.9){
      cls='sample-warn';
      tail = currentLang==='es'
        ? 'Casi suficiente para ±3% – un par de vueltas más ayudarán.'
        : 'Almost enough for ±3% – a couple more laps would help.';
    }else{
      cls='sample-good';
      tail = currentLang==='es'
        ? 'Tamaño de muestra suficiente para objetivo ±3%.'
        : 'Sample size is enough for ±3% target.';
    }

    const head = (currentLang==='es')
      ? `Tamaño de muestra: ${n} / ${recN} · Error estimado: ±${errPct.toFixed(1)}% (95%) – `
      : `Sample size: ${n} / ${recN} · Est. error: ±${errPct.toFixed(1)}% (95%) – `;

    return {cls, text: head + tail};
  }

  /* =======================
     ✅ WB DATA MODEL (with runaway-row fix)
     ======================= */
  function defaultWbRow(){
    const globalHours = clamp(parseFloat(hInput.value)||8, 1, 24);
    const globalContract = clamp(parseFloat(pcdInput.value)||0, 0, 99999);
    const globalQ = clamp(parseFloat(effInput.value)||100, 0, 100);
    const gOp = (processInput.value||'').trim();

    return {
      id: 'wb_' + Math.random().toString(36).slice(2,9),
      seq: 10,
      enabled: true,

      operation: gOp || '',
      opAuto: true,
      opAutoKey: normOp(gOp || ''),

      operators: 1,
      shifts: 1,
      hours: globalHours,
      hoursAuto: true,

      machines: 1,
      contractPcd: globalContract,
      contractAuto: true,

      changeoverMin: 0,
      cleanMin: 0,
      maintMin: 0,
      otherMin: 0,

      sharedMin: 0,

      udtValue: 0,
      udtUnit: 'min_day',

      scrapPct: 0,

      oeeA: 100,
      oeeP: 100,
      oeeQ: globalQ,
      qAuto: true,

      ctCurManual: null,
      ctWstManual: null,
      ctPotManual: null
    };
  }

  let wbRows = [];

  function loadWB(){
    try{
      const raw = localStorage.getItem(WB_KEY);
      if(!raw){ wbRows=[]; return; }
      const parsed = JSON.parse(raw);
      wbRows = Array.isArray(parsed) ? parsed : [];
    }catch(e){ wbRows=[]; }
  }
  function saveWB(){ try{ localStorage.setItem(WB_KEY, JSON.stringify(wbRows)); }catch(e){} }

  function applyGlobalToRow(row){
    const gHours = clamp(parseFloat(hInput.value)||8,1,24);
    const gContract = clamp(parseFloat(pcdInput.value)||0,0,99999);
    const gQ = clamp(parseFloat(effInput.value)||100,0,100);
    const gOp = (processInput.value||'').trim();
    const gOpKey = normOp(gOp);

    /* ✅ Critical fix:
       - DO NOT overwrite operation with blank
       - Only relink rows that truly are auto-linked
       - Avoid "row multiplication" due to tiny name differences
    */
    if(row.opAuto && gOp && gOpKey){
      // if this row was auto-created from a previous global op, keep it linked
      row.operation = gOp;
      row.opAutoKey = gOpKey;
    }
    if(row.hoursAuto) row.hours = gHours;
    if(row.contractAuto) row.contractPcd = gContract;
    if(row.qAuto) row.oeeQ = gQ;
  }

  function ensureWbRowForOperation(opName){
    const op = (opName||'').trim();
    const opKey = normOp(op);
    if(!op || !opKey) return;

    // ✅ match by normalized key to avoid duplicates by spacing/case
    let row = wbRows.find(r => normOp(r.operation) === opKey);
    if(!row){
      row = defaultWbRow();
      const maxSeq = wbRows.reduce((m,x)=>Math.max(m, parseFloat(x.seq)||0), 0);
      row.seq = (maxSeq||0) + 10;
      row.operation = op;
      row.opAuto = true;
      row.opAutoKey = opKey;
      wbRows.push(row);
      saveWB();
    }
  }

  function addLap(manualData){
    const {proc,mode}=ensureDefaults();
    ensureWbRowForOperation(proc);

    const status='', note='';
    if(manualData){
      const {t1,t2,total}=manualData;
      laps.push({id:nextId++,process:proc,mode,status,note,t1,t2,total});
      renderAll();
      return;
    }
    const seconds=Math.max(elapsed/1000,0);
    if(mode==='CT'){
      laps.push({id:nextId++,process:proc,mode,status,note,t1:seconds,t2:0,total:seconds});
      elapsed=0; startTime=performance.now();
      updateDisplay(); pendingT1=null;
      renderAll();
      return;
    }
    if(pendingT1===null){
      pendingT1=seconds;
      elapsed=0; startTime=performance.now();
    }else{
      const t2=seconds, t1=pendingT1;
      laps.push({id:nextId++,process:proc,mode,status,note,t1,t2,total:t1+t2});
      pendingT1=null;
      elapsed=0; startTime=performance.now();
      updateDisplay();
      renderAll();
    }
  }

  btnLap.addEventListener('click',()=>{ flashCard(); vibrate(18); addLap(); });

  btnAddMan.addEventListener('click',()=>{
    const t1 = parseFloat(prompt(currentLang==='es'?'T1 (s)':'T1 (s)',''));
    const t2 = parseFloat(prompt(currentLang==='es'?'T2 (s)':'T2 (s)',''));
    if(isNaN(t1) && isNaN(t2)) return;
    const v1=isNaN(t1)?0:t1, v2=isNaN(t2)?0:t2;
    addLap({t1:v1,t2:v2,total:v1+v2});
  });

  btnReset.addEventListener('click',()=>{
    pause();
    elapsed=0; updateDisplay();
    laps=[]; nextId=1; pendingT1=null;
    renderAll();
  });

  modeSelect.addEventListener('change',()=>{ pendingT1=null; });

  // =========================
  // (PARTE 2 CONTINÚA CON: semaphores, focus/stats tables, WB calc, charts, copy, method guide enriquecido)
  // =========================
  // =========================
  // ✅ Rendering + Logic (Part 2)
  // =========================

  function computeOEE(row){
    const A = clamp(parseFloat(row.oeeA)||0,0,100);
    const P = clamp(parseFloat(row.oeeP)||0,0,100);
    const Q = clamp(parseFloat(row.oeeQ)||0,0,100);
    return (A/100)*(P/100)*(Q/100)*100;
  }

  function udtToMinPerDay(row){
    const v = clamp(parseFloat(row.udtValue)||0,0,999999);
    const u = row.udtUnit || 'min_day';
    if(u==='min_day') return v;
    if(u==='min_shift') return v * (clamp(parseFloat(row.shifts)||1,1,10));
    if(u==='min_hour') return v * (clamp(parseFloat(row.hours)||8,1,24)) * (clamp(parseFloat(row.shifts)||1,1,10));
    if(u==='pct') {
      // percent of gross minutes/day
      const gross = grossMinPerDay(row);
      return gross*(v/100);
    }
    return v;
  }

  function grossMinPerDay(row){
    const hours = clamp(parseFloat(row.hours)||8,1,24);
    const shifts = clamp(parseFloat(row.shifts)||1,1,10);
    const machines = clamp(parseFloat(row.machines)||1,1,999);
    // gross minutes per day for this "operation resource"
    return hours*60*shifts*machines;
  }

  function plannedLossMin(row){
    return (
      clamp(parseFloat(row.lunchMin)||0,0,999999) +
      clamp(parseFloat(row.changeoverMin)||0,0,999999) +
      clamp(parseFloat(row.cleanMin)||0,0,999999) +
      clamp(parseFloat(row.maintMin)||0,0,999999) +
      clamp(parseFloat(row.otherMin)||0,0,999999)
    );
  }

  function netMinPerDay(row){
    const gross = grossMinPerDay(row);
    const lunch = clamp(parseFloat(row.lunchMin)||0,0,999999);
    const pl = plannedLossMin(row);
    const shared = clamp(parseFloat(row.sharedMin)||0,0,999999);
    const udtMin = udtToMinPerDay(row);

    // Note: lunch included in plannedLossMin only if user uses it there—here it's separate column,
    // so keep it explicit as requested.
    const used = lunch + (pl - lunch) + shared + udtMin; // keep column semantics
    const net = gross - used;
    return Math.max(net,0);
  }

  function yieldFromScrap(row){
    const scrap = clamp(parseFloat(row.scrapPct)||0,0,99.99);
    return (100 - scrap)/100;
  }

  function getProcessStatsForRow(row){
    const op = (row.operation||'').trim();
    if(!op) return null;

    // We take stats for both modes; prefer CT, otherwise any.
    const map = groupByProcess();
    let keyCT = op + '||CT';
    let keyMLD = op + '||MLD';

    if(map.has(keyCT)){
      return {mode:'CT', stats: calcStats(map.get(keyCT))};
    }
    if(map.has(keyMLD)){
      return {mode:'MLD', stats: calcStats(map.get(keyMLD))};
    }

    // fallback: find by normalized
    let found = null;
    for(const [k,arr] of map.entries()){
      const [p,m]=k.split('||');
      if(normOp(p)===normOp(op)){
        found = {mode:m, stats: calcStats(arr)};
        break;
      }
    }
    return found;
  }

  function ctForRow(row){
    const st = getProcessStatsForRow(row);
    const manualCur = row.ctCurManual;
    const manualWst = row.ctWstManual;
    const manualPot = row.ctPotManual;

    let cur = null, wst = null, pot = null;

    if(manualCur!==null && isFinite(manualCur)) cur = manualCur;
    if(manualWst!==null && isFinite(manualWst)) wst = manualWst;
    if(manualPot!==null && isFinite(manualPot)) pot = manualPot;

    if(!st || !st.stats){
      // if no stats, ensure at least not NaN
      cur = cur ?? NaN;
      wst = wst ?? NaN;
      pot = pot ?? NaN;
      return {cur,wst,pot, src:'manual'};
    }

    // Stats-based: CT current = median, worst = P90, potential = P10
    const S = st.stats;
    cur = cur ?? S.median;
    wst = wst ?? S.p90;
    pot = pot ?? S.p10;

    return {cur,wst,pot, src:st.mode};
  }

  function capPerDayFromRow(row){
    const {cur} = ctForRow(row);
    const oee = computeOEE(row); // %
    const netMin = netMinPerDay(row);
    const y = yieldFromScrap(row);

    if(!isFinite(cur) || cur<=0) return {cap100:0, capOee:0, ctOee:NaN};

    const ctOee = cur / Math.max(oee/100, 0.0001); // inflate CT by OEE losses
    const cap100 = (netMin*60)/cur * y;
    const capOee = (netMin*60)/ctOee * y;

    return {cap100, capOee, ctOee};
  }

  function sortWb(){
    wbRows.sort((a,b)=>(parseFloat(a.seq)||0)-(parseFloat(b.seq)||0));
  }

  function renderWB(){
    // Apply global updates only (no blank overwrite)
    wbRows.forEach(r=>applyGlobalToRow(r));
    sortWb();
    saveWB();

    wbBody.innerHTML = '';

    // operators sum
    let opSum=0;

    // compute constraint based on enabled rows with valid cap@OEE
    let constr = null;
    let second = null;

    wbRows.forEach((row, idx)=>{
      const enabled = !!row.enabled;
      const tr = document.createElement('tr');

      const gGross = grossMinPerDay(row);
      const lunch = clamp(parseFloat(row.lunchMin)||0,0,999999);
      const pl = plannedLossMin(row);
      const shared = clamp(parseFloat(row.sharedMin)||0,0,999999);
      const udtMin = udtToMinPerDay(row);
      const net = netMinPerDay(row);

      const y = yieldFromScrap(row);
      const oee = computeOEE(row);
      const {cur,wst,pot} = ctForRow(row);
      const {cap100, capOee, ctOee} = capPerDayFromRow(row);

      const contract = clamp(parseFloat(row.contractPcd)||0,0,999999);
      const vs = contract>0 ? (capOee/contract*100) : NaN;

      const inputReq = (contract>0 && isFinite(capOee) && capOee>0)
        ? (contract / Math.max(y,0.0001))
        : NaN;

      if(enabled){
        opSum += clamp(parseFloat(row.operators)||0,0,999);
      }

      // constraint ranking
      if(enabled && contract>0 && isFinite(vs)){
        const item = {row, vs};
        if(!constr || item.vs < constr.vs){
          second = constr;
          constr = item;
        }else if(!second || item.vs < second.vs){
          second = item;
        }
      }

      function td(html){ const c=document.createElement('td'); c.innerHTML=html; tr.appendChild(c); }
      function chkCell(checked, onChange){
        const c=document.createElement('td');
        const inp=document.createElement('input');
        inp.type='checkbox'; inp.className='wb-chk';
        inp.checked=checked;
        inp.addEventListener('change',()=>onChange(inp.checked));
        c.appendChild(inp);
        tr.appendChild(c);
      }
      function inpCell(val, cls, onInput, type='number', step='1', min=null, max=null, widthClass=''){
        const c=document.createElement('td');
        const inp=document.createElement('input');
        inp.type=type;
        inp.className=(cls||'wb-inp') + (widthClass?(' '+widthClass):'');
        inp.value = (val===null || val===undefined) ? '' : val;
        if(step!==null) inp.step = step;
        if(min!==null) inp.min = min;
        if(max!==null) inp.max = max;
        inp.addEventListener('input',()=>onInput(inp.value));
        c.appendChild(inp);
        tr.appendChild(c);
      }
      function selCell(value, options, onChange){
        const c=document.createElement('td');
        const sel=document.createElement('select');
        sel.className='wb-sel';
        options.forEach(o=>{
          const op=document.createElement('option');
          op.value=o.value; op.textContent=o.label;
          if(o.value===value) op.selected=true;
          sel.appendChild(op);
        });
        sel.addEventListener('change',()=>onChange(sel.value));
        c.appendChild(sel); tr.appendChild(c);
      }
      function btnCell(){
        const c=document.createElement('td');
        const bEdit=document.createElement('button');
        bEdit.textContent='Edit';
        bEdit.className='btn-edit';
        bEdit.addEventListener('click',()=>{
          // manual CT editing (two decimals only)
          const curIn = prompt(currentLang==='es'?'CT Actual (s) (2 dec)':'CT Current (s) (2 dec)', row.ctCurManual ?? '');
          const wstIn = prompt(currentLang==='es'?'CT Peor (s) (2 dec)':'CT Worst (s) (2 dec)', row.ctWstManual ?? '');
          const potIn = prompt(currentLang==='es'?'CT Potencial (s) (2 dec)':'CT Potential (s) (2 dec)', row.ctPotManual ?? '');

          function parse2(x){
            if(x===null) return null;
            const s=(''+x).trim();
            if(s==='') return null;
            const n=parseFloat(s);
            if(!isFinite(n)) return null;
            return Math.round(n*100)/100;
          }
          row.ctCurManual = parse2(curIn);
          row.ctWstManual = parse2(wstIn);
          row.ctPotManual = parse2(potIn);
          saveWB(); renderAll();
        });

        const bRelink=document.createElement('button');
        bRelink.textContent='Relink';
        bRelink.className='btn-relink';
        bRelink.addEventListener('click',()=>{
          // relink operation to current global only if global has name
          const gOp = (processInput.value||'').trim();
          const gKey = normOp(gOp);
          if(gOp && gKey){
            row.opAuto = true;
            row.opAutoKey = gKey;
            row.operation = gOp;
            saveWB(); renderAll();
          }
        });

        const bDel=document.createElement('button');
        bDel.textContent='Del';
        bDel.className='btn-del';
        bDel.addEventListener('click',()=>{
          wbRows = wbRows.filter(r=>r.id!==row.id);
          saveWB(); renderAll();
        });

        c.appendChild(bEdit);
        c.appendChild(document.createTextNode(' '));
        c.appendChild(bRelink);
        c.appendChild(document.createTextNode(' '));
        c.appendChild(bDel);
        tr.appendChild(c);
      }

      // Seq (sticky)
      inpCell(row.seq,'wb-inp',v=>{ row.seq=parseFloat(v)||0; saveWB(); renderWB(); },'number','1',0,null,'slim');

      // On (sticky)
      chkCell(row.enabled,(v)=>{ row.enabled=!!v; saveWB(); renderAll(); });

      // Operation (sticky) — ✅ NO more runaway rows: update normalized key + don't autogenerate new row
      inpCell(row.operation,'wb-inp wide',v=>{
        row.operation = (v||'').toString().trim();
        row.opAuto = false; // user touched it
        row.opAutoKey = normOp(row.operation);
        saveWB();
        renderAll();
      },'text',null,null,null,'wide');

      inpCell(row.operators,'wb-inp',v=>{ row.operators=clamp(parseFloat(v)||0,0,999); saveWB(); renderAll(); },'number','1',0,999);
      inpCell(row.shifts,'wb-inp',v=>{ row.shifts=clamp(parseFloat(v)||1,1,10); saveWB(); renderAll(); },'number','1',1,10);
      inpCell(row.hours,'wb-inp',v=>{ row.hours=clamp(parseFloat(v)||8,1,24); row.hoursAuto=false; saveWB(); renderAll(); },'number','.5',1,24);

      inpCell(row.machines,'wb-inp',v=>{ row.machines=clamp(parseFloat(v)||1,1,999); saveWB(); renderAll(); },'number','1',1,999);
      inpCell(row.contractPcd,'wb-inp',v=>{ row.contractPcd=clamp(parseFloat(v)||0,0,99999); row.contractAuto=false; saveWB(); renderAll(); },'number','1',0,99999);

      td(formatUnits(gGross));
      inpCell(row.lunchMin||0,'wb-inp',v=>{ row.lunchMin=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);
      inpCell(row.changeoverMin||0,'wb-inp',v=>{ row.changeoverMin=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);
      inpCell(row.cleanMin||0,'wb-inp',v=>{ row.cleanMin=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);
      inpCell(row.maintMin||0,'wb-inp',v=>{ row.maintMin=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);
      inpCell(row.otherMin||0,'wb-inp',v=>{ row.otherMin=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);

      inpCell(row.sharedMin||0,'wb-inp',v=>{ row.sharedMin=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);

      inpCell(row.udtValue||0,'wb-inp',v=>{ row.udtValue=clamp(parseFloat(v)||0,0,999999); saveWB(); renderAll(); },'number','1',0,999999);
      selCell(row.udtUnit||'min_day',[
        {value:'min_day', label:(currentLang==='es'?'min/día':'min/day')},
        {value:'min_shift', label:(currentLang==='es'?'min/turno':'min/shift')},
        {value:'min_hour', label:(currentLang==='es'?'min/hora':'min/hour')},
        {value:'pct', label:(currentLang==='es'?'% de brutos':'% gross')}
      ],v=>{ row.udtUnit=v; saveWB(); renderAll(); });

      td(formatUnits(net));

      inpCell(row.scrapPct||0,'wb-inp',v=>{ row.scrapPct=clamp(parseFloat(v)||0,0,99.99); saveWB(); renderAll(); },'number','.1',0,99.99);
      td(pct(y*100,1));

      inpCell(row.oeeA||100,'wb-inp',v=>{ row.oeeA=clamp(parseFloat(v)||0,0,100); saveWB(); renderAll(); },'number','1',0,100);
      inpCell(row.oeeP||100,'wb-inp',v=>{ row.oeeP=clamp(parseFloat(v)||0,0,100); saveWB(); renderAll(); },'number','1',0,100);
      inpCell(row.oeeQ||100,'wb-inp',v=>{ row.oeeQ=clamp(parseFloat(v)||0,0,100); row.qAuto=false; saveWB(); renderAll(); },'number','1',0,100);
      td(pct(oee,1));

      // CTs (2 decimals)
      td(isFinite(cur)?formatSecs(cur):'-');
      td(isFinite(wst)?formatSecs(wst):'-');
      td(isFinite(pot)?formatSecs(pot):'-');

      td(isFinite(ctOee)?formatSecs(ctOee):'-');

      td(isFinite(cap100)?formatUnits(cap100):'-');
      td(isFinite(capOee)?formatUnits(capOee):'-');

      // % vs contract
      let badge = 'badge-warn';
      if(isFinite(vs)){
        if(vs>=105) badge='badge-good';
        else if(vs<95) badge='badge-bad';
      }
      td(isFinite(vs)?(`<span class="badge ${badge}">${pct(vs,0)}</span>`):'-');

      td(isFinite(inputReq)?formatUnits(inputReq):'-');

      btnCell();

      if(!enabled){
        tr.style.opacity = '0.55';
      }
      wbBody.appendChild(tr);
    });

    wbOperatorsSum.textContent = String(Math.round(opSum));

    if(constr){
      const op = (constr.row.operation||'').trim() || '—';
      wbConstraint.textContent = `${op} · ${pct(constr.vs,0)}`;
      wbConstraint.className = 'badge badge-bad';
    }else{
      wbConstraint.textContent = '—';
      wbConstraint.className = 'badge badge-bad';
    }

    if(second){
      const op = (second.row.operation||'').trim() || '—';
      wbNextConstraint.textContent = `${op} · ${pct(second.vs,0)}`;
      wbNextConstraint.className = 'badge badge-warn';
    }else{
      wbNextConstraint.textContent = '—';
      wbNextConstraint.className = 'badge badge-warn';
    }

    wbConstraintNote.textContent = (currentLang==='es'
      ? 'La restricción se calcula con filas activas (On) que tengan contrato > 0, usando Cap@OEE vs Contrato. Ajusta CT, OEE, pérdidas y turnos para ver el impacto real.'
      : 'Constraint is computed from active rows (On) with contract > 0, using Cap@OEE vs Contract. Tune CT, OEE, losses and shifts to see real impact.'
    );
  }

  btnWbAdd.addEventListener('click',()=>{
    const r = defaultWbRow();
    const maxSeq = wbRows.reduce((m,x)=>Math.max(m, parseFloat(x.seq)||0), 0);
    r.seq = (maxSeq||0)+10;
    wbRows.push(r);
    saveWB();
    renderAll();
  });

  btnWbClear.addEventListener('click',()=>{
    if(!confirm(currentLang==='es'?'¿Borrar WB completo?':'Clear WB entirely?')) return;
    wbRows = [];
    saveWB();
    renderAll();
  });

  // =========================
  // Tables: Raw Data
  // =========================
  function renderRaw(){
    dataBody.innerHTML = '';
    laps.forEach((l, idx)=>{
      const tr=document.createElement('tr');
      function td(txt, alignRight=true){
        const c=document.createElement('td');
        c.textContent = txt;
        tr.appendChild(c);
      }
      td(String(idx+1), false);
      td(l.process, false);
      td(l.mode, false);
      td(l.status||'', false);
      td(l.note||'', false);
      td(formatSecs(l.t1));
      td(formatSecs(l.t2));
      td(formatSecs(l.total));

      const tdEdit=document.createElement('td');
      const bEdit=document.createElement('button');
      bEdit.className='btn-edit';
      bEdit.textContent=t('col.edit');
      bEdit.addEventListener('click',()=>{
        const newProc = prompt(currentLang==='es'?'Proceso':'Process', l.process) ?? l.process;
        const newMode = prompt(currentLang==='es'?'Modo (CT/MLD)':'Mode (CT/MLD)', l.mode) ?? l.mode;
        const newT1 = prompt('T1 (s)', formatSecs(l.t1)) ?? l.t1;
        const newT2 = prompt('T2 (s)', formatSecs(l.t2)) ?? l.t2;

        const p = (newProc||'').toString().trim();
        const m = (newMode||'CT').toString().trim().toUpperCase()==='MLD'?'MLD':'CT';
        const t1v = Math.round((parseFloat(newT1)||0)*100)/100;
        const t2v = Math.round((parseFloat(newT2)||0)*100)/100;

        l.process = p || l.process;
        l.mode = m;
        l.t1 = t1v;
        l.t2 = t2v;
        l.total = Math.round((t1v+t2v)*100)/100;

        // ensure WB row exists for edited process name
        ensureWbRowForOperation(l.process);

        renderAll();
      });
      tdEdit.appendChild(bEdit);
      tr.appendChild(tdEdit);

      const tdDel=document.createElement('td');
      const bDel=document.createElement('button');
      bDel.className='btn-del';
      bDel.textContent=t('col.del');
      bDel.addEventListener('click',()=>{
        laps = laps.filter(x=>x.id!==l.id);
        renderAll();
      });
      tdDel.appendChild(bDel);
      tr.appendChild(tdDel);

      dataBody.appendChild(tr);
    });
  }

  // =========================
  // Focus + Stats tables
  // =========================
  function renderStats(){
    focusBody.innerHTML='';
    statsBody.innerHTML='';

    const map=groupByProcess();
    const view=capViewSel.value;
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseFloat(dInput.value)||5,1,7);
    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const contractPcd=clamp(parseFloat(pcdInput.value)||0,0,99999);
    const contractUnits = contractUnitsFromPcd(contractPcd, view, hours, days);

    let firstStats = null;

    for(const [key,arr] of map.entries()){
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) continue;
      if(!firstStats) firstStats = st;

      const capCur = capFromCt(st.median, view, hours, days) * (eff/100);
      const capPot = capFromCt(st.p10, view, hours, days) * (eff/100);
      const capWst = capFromCt(st.p90, view, hours, days) * (eff/100);

      const gap = contractUnits>0 ? (capCur - contractUnits) : NaN;
      const vs = contractUnits>0 ? (capCur/contractUnits*100) : NaN;

      const cvPct = st.cv*100;
      const recN = sampleReqN(st.cv);
      const errPct = estErrorPct(st.cv, st.n);

      // Cp/Cpk (rough; assumes spec = median ± 10% if contract exists, else empty)
      let cp=NaN, cpk=NaN;
      if(contractUnits>0){
        // derive a "target CT" from contract per view back to CT
        const contractPerHour = contractUnits / (view==='hour'?1:(view==='day'?hours:(hours*days)));
        const targetCt = contractPerHour>0 ? 3600/contractPerHour : NaN;
        if(isFinite(targetCt) && st.std>0){
          const USL = targetCt*1.10;
          const LSL = targetCt*0.90;
          cp = (USL-LSL)/(6*st.std);
          cpk = Math.min((USL-st.mean)/(3*st.std),(st.mean-LSL)/(3*st.std));
        }
      }

      // Focus row
      const tr=document.createElement('tr');
      function td(v, left=false){
        const c=document.createElement('td');
        c.textContent=v;
        if(left) c.style.textAlign='left';
        tr.appendChild(c);
      }
      td(proc,true);
      td(mode,false);
      td(String(st.n));
      td(`${st.n} / ${recN} · ±${errPct.toFixed(1)}%`);
      td(formatSecs(st.std));
      td(pct(cvPct,1));
      td(formatSecs(st.median));
      td(formatSecs(st.p10));
      td(formatSecs(st.p90));
      td(isFinite(capCur)?formatUnits(capCur):'-');
      td(isFinite(capPot)?formatUnits(capPot):'-');
      td(isFinite(capWst)?formatUnits(capWst):'-');
      td(contractUnits>0?formatUnits(contractUnits):'-');
      td(isFinite(gap)?formatUnits(gap):'-');
      td(isFinite(vs)?pct(vs,0):'-');
      td(isFinite(cp)?cp.toFixed(2):'-');
      td(isFinite(cpk)?cpk.toFixed(2):'-');

      // note
      let note='';
      if(st.n<3) note = currentLang==='es'?'Muy pocas muestras':'Too few samples';
      else if(st.n<recN*0.6) note = currentLang==='es'?'Muestra chica para ±3%':'Small sample for ±3%';
      else if(st.n<recN*0.9) note = currentLang==='es'?'Casi suficiente':'Almost enough';
      else note = currentLang==='es'?'Suficiente':'Enough';
      td(note,true);

      focusBody.appendChild(tr);

      // Stats detail row
      const tr2=document.createElement('tr');
      function td2(v,left=false){
        const c=document.createElement('td'); c.textContent=v;
        if(left) c.style.textAlign='left';
        tr2.appendChild(c);
      }
      td2(proc,true);
      td2(mode,false);
      td2(String(st.n));
      td2(formatSecs(st.mean));
      td2(formatSecs(st.median));
      td2(formatSecs(st.p10));
      td2(formatSecs(st.p90));
      td2(formatSecs(st.min));
      td2(formatSecs(st.max));
      td2(formatSecs(st.std));
      td2(pct(cvPct,1));
      td2(isFinite(cp)?cp.toFixed(2):'-');
      td2(isFinite(cpk)?cpk.toFixed(2):'-');
      statsBody.appendChild(tr2);
    }

    // Update focus text blocks
    const currentProc = (processInput.value||'').trim();
    const currentMode = modeSelect.value||'CT';
    const currentKey = currentProc+'||'+currentMode;
    const currentStats = map.has(currentKey) ? calcStats(map.get(currentKey)) : firstStats;

    const line = buildSampleLine(currentStats || {n:0,cv:0});
    setInfo(sampleInfoTop, line.cls, line.text);

    if(currentStats){
      const cvPct=currentStats.cv*100;
      const varTxt = (currentLang==='es')
        ? `Std: ${formatSecs(currentStats.std)}s · CV: ${cvPct.toFixed(1)}%`
        : `Std: ${formatSecs(currentStats.std)}s · CV: ${cvPct.toFixed(1)}%`;
      setInfo(stdInfoFocus, 'sample-neutral', varTxt);

      const dist = (Math.abs(currentStats.mean-currentStats.median)/Math.max(currentStats.median,0.0001))*100;
      const distTxt = (currentLang==='es')
        ? `Media vs Mediana: ${formatSecs(currentStats.mean)} vs ${formatSecs(currentStats.median)} (Δ ${dist.toFixed(1)}%)`
        : `Mean vs Median: ${formatSecs(currentStats.mean)} vs ${formatSecs(currentStats.median)} (Δ ${dist.toFixed(1)}%)`;
      setInfo(distInfoFocus, 'sample-neutral', distTxt);

      const nTxt = (currentLang==='es')
        ? `Muestras: ${currentStats.n}`
        : `Samples: ${currentStats.n}`;
      setInfo(sampleInfoFocus, 'sample-neutral', nTxt);
    }else{
      setInfo(sampleInfoFocus, 'sample-neutral', (currentLang==='es'?'Muestras: —':'Samples: —'));
      setInfo(stdInfoFocus, 'sample-neutral', 'Std dev: —');
      setInfo(distInfoFocus, 'sample-neutral', 'Mean vs Median: —');
    }

    if(contractUnits>0){
      setInfo(contractInfoFocus, 'sample-neutral',
        (currentLang==='es'
          ? `Contrato: ${formatUnits(contractUnits)} (${capViewSel.options[capViewSel.selectedIndex].text})`
          : `Contract: ${formatUnits(contractUnits)} (${capViewSel.options[capViewSel.selectedIndex].text})`
        )
      );
    }else{
      setInfo(contractInfoFocus, 'sample-neutral', (currentLang==='es'?'Sin contrato cargado':'No contract loaded'));
    }
  }

  // =========================
  // Contract summary blocks
  // =========================
  function renderContractSummary(){
    const map=groupByProcess();
    const proc=(processInput.value||'').trim();
    const mode=(modeSelect.value||'CT');
    const key=proc+'||'+mode;

    const view=capViewSel.value;
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseFloat(dInput.value)||5,1,7);
    const eff=clamp(parseFloat(effInput.value)||100,0,100);

    const contractPcd=clamp(parseFloat(pcdInput.value)||0,0,99999);
    const contractUnits = contractUnitsFromPcd(contractPcd, view, hours, days);

    let st=null;
    if(map.has(key)) st=calcStats(map.get(key));
    else{
      // fallback: find normalized
      for(const [k,arr] of map.entries()){
        const [p,m]=k.split('||');
        if(normOp(p)===normOp(proc) && m===mode){ st=calcStats(arr); break; }
      }
    }

    const labelView = capViewSel.options[capViewSel.selectedIndex].text;

    if(!st){
      contractSumLine1.textContent = (currentLang==='es'?'Sin datos del proceso aún.':'No process data yet.');
      contractSumLine2.textContent = '—';
      contractSumLine3.textContent = '—';
      contractSumLine4.textContent = '—';
      return;
    }

    const capCur = capFromCt(st.median, view, hours, days) * (eff/100);
    const capPot = capFromCt(st.p10, view, hours, days) * (eff/100);
    const capWst = capFromCt(st.p90, view, hours, days) * (eff/100);

    contractSumLine1.textContent = (currentLang==='es'
      ? `Proceso: ${proc} (${mode}) · N=${st.n} · Eff=${eff}%`
      : `Process: ${proc} (${mode}) · N=${st.n} · Eff=${eff}%`
    );

    contractSumLine2.textContent = (currentLang==='es'
      ? `Capacidad (Actual/Mediana): ${formatUnits(capCur)} ${labelView}`
      : `Capacity (Current/Median): ${formatUnits(capCur)} ${labelView}`
    );

    contractSumLine3.textContent = (currentLang==='es'
      ? `Capacidad (Potencial/P10): ${formatUnits(capPot)} · Peor/P90: ${formatUnits(capWst)}`
      : `Capacity (Potential/P10): ${formatUnits(capPot)} · Worst/P90: ${formatUnits(capWst)}`
    );

    if(contractUnits>0){
      const vs = capCur/contractUnits*100;
      const gap = capCur-contractUnits;
      let badge = 'sample-warn';
      if(vs>=105) badge='sample-good';
      else if(vs<95) badge='sample-bad';

      contractSumLine4.className = 'info-line ' + badge;
      contractSumLine4.textContent = (currentLang==='es'
        ? `Contrato: ${formatUnits(contractUnits)} · % vs: ${vs.toFixed(0)}% · Gap: ${formatUnits(gap)}`
        : `Contract: ${formatUnits(contractUnits)} · % vs: ${vs.toFixed(0)}% · Gap: ${formatUnits(gap)}`
      );
    }else{
      contractSumLine4.className = 'info-line sample-neutral';
      contractSumLine4.textContent = (currentLang==='es'
        ? 'Carga un contrato para ver Gap y % vs contrato.'
        : 'Load a contract to see Gap and % vs contract.'
      );
    }
  }

  // =========================
  // Charts
  // =========================
  function clearCanvas(canvas){
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  function resizeCanvas(canvas){
    // set to displayed size
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width));
    canvas.height = Math.max(1, Math.floor(rect.height));
  }

  function drawAxes(ctx, w, h, pad){
    ctx.strokeStyle='rgba(255,255,255,.25)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, h-pad);
    ctx.lineTo(w-pad, h-pad);
    ctx.stroke();
  }

  function drawTimeSeries(values, stats){
    resizeCanvas(timeSeriesCanvas);
    const ctx=timeSeriesCanvas.getContext('2d');
    const w=timeSeriesCanvas.width, h=timeSeriesCanvas.height;
    const pad=28;
    clearCanvas(timeSeriesCanvas);
    drawAxes(ctx,w,h,pad);

    if(!values.length) return;
    const minV=Math.min(...values), maxV=Math.max(...values);
    const range=Math.max(maxV-minV, 0.0001);

    function x(i){ return pad + (i/(values.length-1||1))*(w-2*pad); }
    function y(v){ return (h-pad) - ((v-minV)/range)*(h-2*pad); }

    // series
    ctx.strokeStyle='rgba(41,182,246,.9)';
    ctx.lineWidth=2;
    ctx.beginPath();
    values.forEach((v,i)=>{
      const X=x(i), Y=y(v);
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    });
    ctx.stroke();

    // mean
    const mean=stats.mean, median=stats.median, std=stats.std;
    function hline(v, style){
      ctx.strokeStyle=style; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(pad,y(v)); ctx.lineTo(w-pad,y(v)); ctx.stroke();
    }
    hline(mean,'rgba(0,200,83,.8)');
    hline(median,'rgba(255,179,0,.85)');
    hline(mean+3*std,'rgba(255,23,68,.6)');
    hline(mean-3*std,'rgba(255,23,68,.6)');

    // labels
    ctx.fillStyle='rgba(255,255,255,.75)';
    ctx.font='12px system-ui';
    ctx.fillText('mean', pad+4, Math.max(14,y(mean)-4));
    ctx.fillText('median', pad+4, Math.max(14,y(median)-4));
  }

  function drawHistogram(values, stats){
    resizeCanvas(histCanvas);
    const ctx=histCanvas.getContext('2d');
    const w=histCanvas.width, h=histCanvas.height;
    const pad=28;
    clearCanvas(histCanvas);
    drawAxes(ctx,w,h,pad);

    if(!values.length) return;
    const minV=Math.min(...values), maxV=Math.max(...values);
    const bins = Math.min(12, Math.max(5, Math.round(Math.sqrt(values.length))));
    const range=Math.max(maxV-minV, 0.0001);
    const binW=range/bins;

    const counts=new Array(bins).fill(0);
    values.forEach(v=>{
      let b = Math.floor((v-minV)/binW);
      if(b>=bins) b=bins-1;
      if(b<0) b=0;
      counts[b]+=1;
    });

    const maxC=Math.max(...counts,1);
    const plotW=w-2*pad, plotH=h-2*pad;
    const barW=plotW/bins;

    // bars
    ctx.fillStyle='rgba(41,182,246,.55)';
    counts.forEach((c,i)=>{
      const bh=(c/maxC)*plotH;
      const x=pad+i*barW;
      const y=h-pad-bh;
      ctx.fillRect(x+2,y,Math.max(1,barW-4),bh);
    });

    // median, p10, p90
    function xFor(v){ return pad + ((v-minV)/range)*plotW; }
    function vline(v, style){
      ctx.strokeStyle=style; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(xFor(v), pad); ctx.lineTo(xFor(v), h-pad); ctx.stroke();
    }
    vline(stats.median,'rgba(255,179,0,.9)');
    vline(stats.p10,'rgba(0,200,83,.85)');
    vline(stats.p90,'rgba(255,23,68,.75)');

    ctx.fillStyle='rgba(255,255,255,.75)';
    ctx.font='12px system-ui';
    ctx.fillText('P10', xFor(stats.p10)+4, pad+14);
    ctx.fillText('Med', xFor(stats.median)+4, pad+28);
    ctx.fillText('P90', xFor(stats.p90)+4, pad+42);
  }

  function renderCharts(){
    // Populate selector
    const map=groupByProcess();
    const keys=[...map.keys()].sort();
    const prev=chartSelect.value;
    chartSelect.innerHTML='';
    keys.forEach(k=>{
      const opt=document.createElement('option');
      opt.value=k;
      const [p,m]=k.split('||');
      opt.textContent = `${p} (${m})`;
      chartSelect.appendChild(opt);
    });
    if(keys.includes(prev)) chartSelect.value=prev;
    else if(keys.length) chartSelect.value=keys[0];

    if(!keys.length){
      clearCanvas(timeSeriesCanvas);
      clearCanvas(histCanvas);
      return;
    }

    const arr=map.get(chartSelect.value)||[];
    const st=calcStats(arr);
    const values = st ? st.values : [];
    if(st){
      drawTimeSeries(values, st);
      drawHistogram(values, st);
    }else{
      clearCanvas(timeSeriesCanvas);
      clearCanvas(histCanvas);
    }
  }
  chartSelect.addEventListener('change', renderCharts);
  window.addEventListener('resize', ()=>{ renderCharts(); });

  // =========================
  // Copy helpers
  // =========================
  function copyText(text){
    navigator.clipboard.writeText(text).catch(()=>{});
  }

  btnCopyAll.addEventListener('click',()=>{
    const view=capViewSel.value;
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseFloat(dInput.value)||5,1,7);
    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const contractPcd=clamp(parseFloat(pcdInput.value)||0,0,99999);
    const contractUnits = contractUnitsFromPcd(contractPcd, view, hours, days);

    let out=[];
    out.push(`TaktLab Export (${new Date().toISOString()})`);
    out.push(`Process: ${(processInput.value||'').trim()} | Mode: ${modeSelect.value} | Eff: ${eff}% | View: ${capViewSel.value}`);
    out.push(`Contract: ${contractUnits>0?formatUnits(contractUnits):'-'}`);
    out.push('');
    out.push('Raw Laps:');
    laps.forEach(l=>{
      out.push(`${l.process}\t${l.mode}\t${formatSecs(l.t1)}\t${formatSecs(l.t2)}\t${formatSecs(l.total)}`);
    });
    out.push('');
    out.push('WB Rows:');
    wbRows.forEach(r=>{
      const {capOee}=capPerDayFromRow(r);
      out.push(`${r.seq}\t${r.enabled?1:0}\t${r.operation}\tContract:${r.contractPcd}\tCap@OEE:${isFinite(capOee)?Math.round(capOee):'-'}`);
    });
    copyText(out.join('\n'));
  });

  btnCopySum.addEventListener('click',()=>{
    const view=capViewSel.value;
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseFloat(dInput.value)||5,1,7);
    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const contractPcd=clamp(parseFloat(pcdInput.value)||0,0,99999);
    const contractUnits = contractUnitsFromPcd(contractPcd, view, hours, days);

    const map=groupByProcess();
    const proc=(processInput.value||'').trim();
    const mode=(modeSelect.value||'CT');
    const key=proc+'||'+mode;

    const st = map.has(key) ? calcStats(map.get(key)) : null;
    let out=[];
    out.push(`Summary – ${proc} (${mode})`);
    if(st){
      out.push(`N=${st.n} | Median=${formatSecs(st.median)}s | P10=${formatSecs(st.p10)}s | P90=${formatSecs(st.p90)}s | Std=${formatSecs(st.std)}s`);
      const capCur = capFromCt(st.median, view, hours, days) * (eff/100);
      out.push(`Capacity (Median @Eff): ${formatUnits(capCur)} ${capViewSel.options[capViewSel.selectedIndex].text}`);
      if(contractUnits>0){
        out.push(`Contract: ${formatUnits(contractUnits)} | %vs=${(capCur/contractUnits*100).toFixed(0)}% | Gap=${formatUnits(capCur-contractUnits)}`);
      }
    }else{
      out.push('No stats yet.');
    }

    // WB constraint
    const constrTxt = wbConstraint.textContent || '—';
    const nextTxt = wbNextConstraint.textContent || '—';
    out.push(`WB Constraint: ${constrTxt} | Next: ${nextTxt}`);

    copyText(out.join('\n'));
  });

  // =========================
  // ✅ Method & Guide (Recovered + Enriched)
  // =========================
  function buildMethodGuide(){
    const es = (currentLang==='es');

    return (es ? `
MÉTODO & GUÍA (TaktLab + WB)

1) ¿Qué estoy midiendo?
- CT (Cycle Time): tiempo total para 1 pieza (de inicio a fin).
- MLD (Machine + Load/Unload): separa T1 (tiempo máquina) y T2 (carga/descarga / intervención humana). Total = T1+T2.
Tip: usa CT si tu proceso es “una caja negra” (solo te importa el total). Usa MLD cuando quieras detectar si tu cuello de botella es humano o máquina.

2) Reglas de captura (para que el dato valga)
- Define el “inicio” y “fin” del ciclo (visual y repetible).
- Mide siempre el mismo producto/modelo (si cambia, crea otro proceso).
- Evita “laps” contaminadas: paro mayor, ajuste, set-up, búsqueda de material… pon NOTE o no uses esa vuelta.
- No más de 2 decimales: esto es ingeniería, no astrología.

3) ¿Cuántas muestras necesito?
- Con 1–2 vueltas: solo exploración.
- Con ≥3 vueltas: ya se puede estimar variación.
- Objetivo recomendado: error ~±3% (95%) → el sistema calcula N recomendado usando CV (variación).
Lectura rápida:
  • “Sample too small”: no decidas contratos con eso.
  • “Almost enough”: ya huele a verdad, pero dale 2–5 vueltas más.
  • “Enough”: ahora sí, ponle apellido y llévalo a junta.

4) ¿Por qué usamos Mediana, P10 y P90?
- Mediana (CT Actual): robusta contra outliers.
- P90 (CT Peor): representa el “día malo” típico (sin ser catástrofe).
- P10 (CT Potencial): representa el “día bueno” típico (sin ser fantasía).
Promedio se deja, pero manda menos: se deja engañar por outliers.

5) Contract vs Capacity Summary (cómo leerlo)
- Capacidad Actual = capacidad usando Mediana y tu eficiencia.
- Potencial = usando P10.
- Peor = usando P90.
Si el % vs contrato <95%: estás corto. Si 95–105%: estás en la cuerda floja. >105%: margen.

6) WB (Workbench) – para qué sirve
WB convierte CT + pérdidas + OEE + scrap + recursos (máquinas/turnos/horas) en capacidad real.
Columnas clave:
- Gross min/day: minutos brutos disponibles por día.
- Lunch/Changeover/5S/Mtto/Other: pérdidas planeadas.
- Shared Capacity: minutos que “se los come” algo compartido (ej. un operador que apoya 2 celdas).
- Unplanned DT: pérdidas no planeadas (min/día, min/turno, min/hora o % del bruto).
- Net min/day: lo que queda para producir de verdad.
- Scrap % → Yield: tu salida real se reduce por scrap.
- OEE (A·P·Q): multiplica la realidad (y baja sueños).

7) Cap@OEE vs Contract (la restricción)
WB marca la restricción usando filas ON con contrato > 0.
Restricción = menor % vs contrato (Cap@OEE / contrato).
Siguiente restricción = el segundo menor.
Esto te da el “dónde duele” sin hacer teatro.

8) Cómo evitar datos basura (reglas rápidas)
- No mezcles modelos.
- No midas con operador novato si tu estándar es operador entrenado (o etiqueta la nota).
- Si cambias fixture/herramental/parámetro, crea otro proceso o reinicia el set.
- Si tu piso vibra o hay inestabilidad: eso no es variación natural… es un problema.

9) Recomendación de uso (secuencia)
A) Captura 10–20 vueltas en CT o MLD.
B) Revisa “Sample size / error”.
C) Ajusta Efficiency y Contract.
D) Pasa a WB y mete pérdidas reales (no las que te gustaría tener).
E) Ataca restricción, no síntomas.

Fin. (Sí, este método sí sobrevive a auditorías. 😉)
` : `
METHOD & GUIDE (TaktLab + WB)

1) What am I measuring?
- CT (Cycle Time): total time for 1 part (start to finish).
- MLD (Machine + Load/Unload): splits T1 (machine time) and T2 (load/unload / human intervention). Total = T1+T2.
Tip: use CT if you only care about total. Use MLD to discover whether the bottleneck is human or machine.

2) Capture rules (so the data is real)
- Define start/end clearly and repeatably.
- Same product/model only (if it changes, create a new process).
- Avoid “contaminated laps”: major stop, setup, searching material… use NOTE or don’t count that lap.
- Max 2 decimals: this is engineering, not fortune telling.

3) How many samples do I need?
- 1–2 laps: exploratory only.
- ≥3 laps: can estimate variation.
- Recommended target: ~±3% error (95%) → system computes recommended N using CV.
Quick read:
  • “Sample too small”: don’t decide contracts with that.
  • “Almost enough”: close — add a few more laps.
  • “Enough”: now you can take it to management.

4) Why Median, P10, P90?
- Median (Current CT): robust vs outliers.
- P90 (Worst CT): typical “bad day” without being a disaster.
- P10 (Potential CT): typical “good day” without being fantasy.
Mean is included but less reliable with outliers.

5) Contract vs Capacity Summary (how to read)
- Current capacity = using Median and your efficiency.
- Potential = using P10.
- Worst = using P90.
If % vs contract <95%: short. 95–105%: tight. >105%: margin.

6) WB (Workbench) – purpose
WB converts CT + losses + OEE + scrap + resources (machines/shifts/hours) into real capacity.
Key columns:
- Gross min/day: total available minutes.
- Lunch/Changeover/5S/Mtto/Other: planned losses.
- Shared Capacity: minutes consumed by shared resources.
- Unplanned DT: unplanned losses (min/day, min/shift, min/hour or % gross).
- Net min/day: what remains to actually produce.
- Scrap % → Yield: output reduced by scrap.
- OEE (A·P·Q): turns reality on (and dreams down).

7) Cap@OEE vs Contract (constraint)
WB marks the constraint using ON rows with contract > 0.
Constraint = lowest % vs contract (Cap@OEE / contract).
Next constraint = second lowest.

8) Avoid garbage data (quick rules)
- Don’t mix models.
- Don’t measure with a trainee if your standard is trained operator (or label it).
- If fixture/tooling/parameters change, create a new process or reset.
- If vibration/instability exists: that’s not natural variation; it’s a problem.

9) Recommended sequence
A) Capture 10–20 laps in CT or MLD.
B) Check “Sample size / error”.
C) Set Efficiency and Contract.
D) Move to WB and enter real losses.
E) Fix the constraint, not the symptoms.

End. (Yes, this survives audits. 😉)
`);
  }

  // =========================
  // Master render
  // =========================
  function renderAll(){
    renderContractSummary();
    renderStats();
    renderRaw();
    renderWB();
    renderCharts();
    methodGuideText.textContent = buildMethodGuide();
  }

  // Sync global edits without runaway WB rows
  processInput.addEventListener('input', ()=>{
    // DO NOT auto-create new WB rows on partial typing — only ensure on blur / Enter
  });
  processInput.addEventListener('blur', ()=>{
    const op = (processInput.value||'').trim();
    ensureWbRowForOperation(op);
    renderAll();
  });
  processInput.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      const op=(processInput.value||'').trim();
      ensureWbRowForOperation(op);
      renderAll();
    }
  });

  [effInput, pcdInput, hInput, dInput, capViewSel, modeSelect].forEach(el=>{
    el.addEventListener('input', renderAll);
    el.addEventListener('change', renderAll);
  });

  // =========================
  // Init
  // =========================
  loadWB();
  updateLangButtons();
  applyTranslations();
  btnStart.textContent = running ? t('btn.pause') : t('btn.start');
  document.documentElement.lang = currentLang;

  // Ensure at least one WB row if process exists (but not blank)
  const firstOp = (processInput.value||'').trim();
  if(firstOp) ensureWbRowForOperation(firstOp);

  renderAll();

})();
</script>
</body>
</html>
