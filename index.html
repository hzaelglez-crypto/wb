<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TaktLab – Cycle Time & Capacity Analyzer</title>

<style>
  :root{
    --bg-main:#07152b;
    --bg-card:#0b1f3a;
    --bg-card-soft:#0f2544;
    --accent-green:#00c853;
    --accent-amber:#ffb300;
    --accent-red:#ff1744;
    --accent-blue:#29b6f6;
    --accent-grey:#cfd8dc;
    --text-main:#ffffff;
    --text-soft:#c5cae9;
    --text-muted:#90a4ae;
    --border-soft:#1c3357;
    --btn-green:#00c853;
    --btn-orange:#ff9100;
    --btn-grey:#455a64;
    --badge-green:#004d40;
    --badge-red:#b71c1c;
    --badge-amber:#ff8f00;
  }

  *{box-sizing:border-box;}

  body{
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 40%,#020b1a 100%);
    color:var(--text-main);
  }

  .page{
    max-width:1100px;
    margin:0 auto;
    padding:10px 10px 34px; /* compact */
  }

  .sticky-timer-bar{
    position:sticky;
    top:0;
    z-index:100;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 90%);
    padding:6px 0 8px; /* compact */
  }

  .top-row{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:6px; /* compact */
  }

  .logo-circle{
    width:38px;height:38px;border-radius:50%;
    border:2px solid var(--accent-grey);
    display:flex;align-items:center;justify-content:center;
  }
  .logo-gear{
    width:22px;height:22px;border-radius:50%;
    border:2px solid var(--accent-grey);
    position:relative;
  }
  .logo-gear::before{
    content:"";
    position:absolute;
    inset:4px;
    border-radius:50%;
    border:2px solid var(--accent-green);
    border-right-color:transparent;
    border-bottom-color:transparent;
    transform-origin:50% 50%;
  }
  .logo-gear.spinning::before{ animation:logo-spin 2s linear infinite; }
  @keyframes logo-spin{ from{transform:rotate(0deg);} to{transform:rotate(360deg);} }

  .title-block{display:flex;flex-direction:column;gap:2px;}
  .title-main{font-size:1.2rem;font-weight:700;letter-spacing:.03em;}
  .title-sub{font-size:.72rem;color:var(--text-soft);}

  .lang-switch{margin-left:auto;display:flex;align-items:center;gap:4px;}
  .lang-btn{
    border-radius:999px;border:1px solid var(--border-soft);
    background:rgba(2,11,26,.6);color:var(--text-soft);
    font-size:.7rem;padding:4px 8px;cursor:pointer;min-width:34px;
  }
  .lang-btn.active{background:var(--accent-blue);color:#fff;border-color:var(--accent-blue);font-weight:600;}

  .timer-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:6px 10px 10px;
    box-shadow:0 8px 18px rgba(0,0,0,.45);
  }

  .timer-display{
    text-align:center;
    font-size:2.8rem;
    font-weight:600;
    letter-spacing:.08em;
    padding:4px 4px 6px; /* compact */
  }

  .info-stack{ display:flex; flex-direction:column; gap:6px; margin:0 0 8px; }
  .info-line{
    font-size:.78rem;margin:0;padding:6px 10px;
    border-radius:12px;border:1px solid transparent;
    line-height:1.25;
  }
  .sample-neutral{background:rgba(255,255,255,.03);border-color:rgba(255,255,255,.08);color:var(--text-soft);}
  .sample-good{background:rgba(0,200,83,.15);border-color:rgba(0,200,83,.7);color:#c8e6c9;}
  .sample-warn{background:rgba(255,193,7,.14);border-color:rgba(255,193,7,.8);color:#ffe082;}
  .sample-bad{background:rgba(244,67,54,.16);border-color:rgba(244,67,54,.9);color:#ffab91;}

  .btn-row-main{display:flex;gap:10px;margin-bottom:2px;}
  .btn{
    border:none;border-radius:16px;padding:10px 12px;
    font-size:.9rem;font-weight:600;cursor:pointer;color:#fff;
    box-shadow:0 4px 10px rgba(0,0,0,.4);flex:1;
    transition:transform .04s ease, box-shadow .04s ease, background .15s;
    touch-action:manipulation;
  }
  .btn:active{transform:translateY(1px);box-shadow:0 1px 4px rgba(0,0,0,.5);}
  .btn-start{background:var(--btn-green);}
  .btn-lap{background:var(--btn-orange);}

  .flash{animation:flash-bg .12s ease-out;}
  @keyframes flash-bg{ from{background:rgba(255,255,255,.18);} to{background:transparent;} }

  .content-section{margin-top:8px;} /* compact */

  .section-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:8px 10px 10px; /* compact */
    margin-bottom:10px;
  }
  .section-title{font-size:1.0rem;font-weight:700;margin-bottom:6px;} /* compact */

  .mode-row{
    display:flex;gap:8px;flex-wrap:wrap;align-items:flex-end;
    font-size:.78rem;color:var(--text-soft);
  }
  .mode-row select,.mode-row input{
    background:#020b1a;border-radius:8px;border:1px solid var(--border-soft);
    padding:4px 8px;color:var(--text-soft);font-size:.78rem;min-width:70px;
  }
  .mode-row input[type="number"]{width:78px;}

  table{width:100%;border-collapse:collapse;font-size:.72rem;} /* compact */
  th,td{
    padding:3px 5px;text-align:right; /* compact */
    border-bottom:1px solid rgba(255,255,255,.04);
    white-space:nowrap;
    vertical-align:middle;
  }
  th:first-child,td:first-child{text-align:left;}
  th{
    color:var(--text-soft);font-weight:600;background:rgba(255,255,255,.02);
    position:sticky;top:0;z-index:5;
  }
  tbody tr:nth-child(even){background:rgba(255,255,255,.02);}

  .badge{
    display:inline-block;padding:2px 6px;border-radius:999px;
    font-size:.68rem;border:1px solid transparent;
  }
  .badge-good{background:var(--badge-green);border-color:#00e676;}
  .badge-warn{background:var(--badge-amber);border-color:#ffe082;color:#000;}
  .badge-bad{background:var(--badge-red);border-color:#ff8a80;}

  .btn-row-secondary{display:flex;flex-wrap:wrap;gap:10px;margin:8px 0 4px;}
  .btn-small{
    padding:12px 18px;            /* BIGGER */
    border-radius:18px;           /* BIGGER */
    font-size:.95rem;             /* BIGGER */
    font-weight:800;              /* BIGGER */
    flex:0 0 auto;background:var(--bg-card-soft);color:var(--text-soft);
    border:1px solid var(--border-soft);cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,.35);
  }
  .btn-small-copy{background:var(--accent-blue);border-color:var(--accent-blue);color:#fff;}
  .btn-small-summary{background:var(--accent-amber);border-color:var(--accent-amber);color:#000;}
  .btn-small-manual{background:var(--accent-green);border-color:var(--accent-green);color:#000;}
  .btn-small-reset{background:var(--accent-red);border-color:var(--accent-red);color:#fff;}
  .btn-small-wbadd{background:rgba(255,255,255,.06);color:var(--text-soft);}
  .btn-small-wbclear{background:rgba(255,23,68,.16);border-color:rgba(255,23,68,.6);color:#ff8a80;}

  .subsection-title{margin-top:10px;font-size:.82rem;font-weight:650;color:var(--text-soft);}

  .footer-note{margin-top:10px;font-size:.65rem;color:var(--text-muted);text-align:right;}

  .charts-wrapper{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:10px;
  }
  .chart-card{
    background:var(--bg-card-soft);
    border-radius:14px;
    border:1px solid var(--border-soft);
    padding:8px;
  }
  .chart-title{font-size:.75rem;margin-bottom:4px;color:var(--text-soft);}
  canvas{width:100%;height:180px;background:#020b1a;border-radius:10px;}

  .btn-edit,.btn-del,.btn-relink{
    padding:2px 6px;border-radius:8px;font-size:.7rem;
    border:1px solid rgba(255,255,255,.2);cursor:pointer;background:transparent;
  }
  .btn-edit{color:#81d4fa;}
  .btn-del{color:#ff8a80;}
  .btn-relink{color:#ffe082;}

  /* WB inputs – más compactos */
  .wb-inp, .wb-sel, .wb-chk{
    background:#020b1a;border-radius:8px;border:1px solid var(--border-soft);
    padding:2px 5px;color:var(--text-soft);font-size:.70rem;
  }
  .wb-inp{width:72px;}
  .wb-inp.wide{width:140px;}
  .wb-inp.slim{width:56px;}
  .wb-sel{width:84px;}
  .wb-pill{
    display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.03);font-size:.72rem;color:var(--text-soft);
  }
  .wb-alert{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px;}
  .wb-alert .badge{font-size:.72rem;padding:4px 10px;}
  .wb-badge-title{font-size:.72rem;color:var(--text-soft);}
  .wb-mini{font-size:.7rem;color:var(--text-muted);line-height:1.25;margin-top:6px;}
  .wb-sumline{
    display:flex;justify-content:flex-end;gap:10px;align-items:center;
    margin-top:6px;font-size:.72rem;color:var(--text-soft);
  }
  .wb-sumline .badge{font-size:.70rem}

  @media (max-width:600px){
    .timer-display{font-size:2.2rem;}
    .btn-row-main{gap:6px;}
    .btn{font-size:.9rem;border-radius:14px;}
    canvas{height:160px;}
    th,td{font-size:.70rem;}
    .wb-inp{width:66px;}
    .wb-inp.wide{width:120px;}
    .btn-small{padding:12px 16px;font-size:.92rem;}
  }
</style>
</head>

<body>
<div class="page">

  <div class="sticky-timer-bar">
    <div class="top-row">
      <div class="logo-circle"><div class="logo-gear" id="logoGear"></div></div>
      <div class="title-block">
        <div class="title-main">TaktLab</div>
        <div class="title-sub" data-i18n="title.subtitle">Cycle Time &amp; Capacity Analyzer</div>
      </div>
      <div class="lang-switch">
        <button class="lang-btn" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="es">ES</button>
      </div>
    </div>

    <div class="timer-card" id="timerCard">
      <div class="timer-display" id="display">00:00.00</div>

      <div class="info-stack">
        <div class="info-line sample-neutral" id="sampleInfoTop">
          No samples yet for current process. Start capturing laps.
        </div>
      </div>

      <div class="btn-row-main">
        <button class="btn btn-start" id="btnStart" data-i18n="btn.start">Start</button>
        <button class="btn btn-lap" id="btnLap" data-i18n="btn.lap">LAP</button>
      </div>
    </div>
  </div>

  <div class="content-section">

    <div class="section-card">
      <div class="section-title" data-i18n="section.measurementSetup">Measurement Setup</div>

      <div class="mode-row">
        <div>
          <label for="processName" data-i18n="label.process">Process</label><br/>
          <input id="processName" type="text" placeholder="e.g. Op 30-1" data-i18n-placeholder="label.processPlaceholder"/>
        </div>

        <div>
          <label for="mode" data-i18n="label.mode">Mode</label><br/>
          <select id="mode">
            <option value="CT" data-i18n="mode.ct">Cycle Time (CT)</option>
            <option value="MLD" data-i18n="mode.mld">Machine &amp; Load/Unload</option>
          </select>
        </div>

        <div>
          <label for="efficiency" data-i18n="label.efficiency">Efficiency %</label><br/>
          <input id="efficiency" type="number" value="100" min="0" max="100" step="1"/>
        </div>

        <div>
          <label for="contractPcd" data-i18n="label.contractPcd">Contract Cap (pcs/day)</label><br/>
          <input id="contractPcd" type="number" min="0" max="99999" step="1"/>
        </div>

        <div>
          <label for="hoursPerDay" data-i18n="label.hoursPerDay">Hours / Day</label><br/>
          <input id="hoursPerDay" type="number" value="8" min="1" max="24" step=".5"/>
        </div>

        <div>
          <label for="daysPerWeek" data-i18n="label.daysPerWeek">Days / Week</label><br/>
          <input id="daysPerWeek" type="number" value="5" min="1" max="7"/>
        </div>

        <div>
          <label for="capView" data-i18n="label.capView">Capacity View</label><br/>
          <select id="capView">
            <option value="hour" data-i18n="capView.hour">per Hour</option>
            <option value="day" data-i18n="capView.day">per Day</option>
            <option value="week" data-i18n="capView.week">per Week</option>
          </select>
        </div>
      </div>
    </div>

    <!-- NEW: CONTRACT vs CAPACITY SUMMARY -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.contractSummary">Contract vs Capacity Summary</div>

      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="contractSumLine1">—</div>
        <div class="info-line sample-neutral" id="contractSumLine2">—</div>
        <div class="info-line sample-neutral" id="contractSumLine3">—</div>
        <div class="info-line sample-neutral" id="contractSumLine4">—</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 0;">
        <span data-i18n="contract.note">Uses current process + your laps (Median/P10/P90) with the Measurement Setup assumptions.</span>
      </div>
    </div>
    <div class="section-card">
      <div class="section-title" data-i18n="section.statsFocus">Stat Focus</div>

      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="sampleInfoFocus">Sample size: —</div>
        <div class="info-line sample-neutral" id="stdInfoFocus">Std dev: —</div>
        <div class="info-line sample-neutral" id="distInfoFocus">Mean vs Median: —</div>
        <div class="info-line sample-neutral" id="contractInfoFocus">No contract loaded</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 6px;">
        <span data-i18n="stats.note">Simple language on purpose: few / enough samples, low / high variation, capable / not capable.</span>
      </div>

      <div style="max-height:300px;overflow:auto;">
        <table>
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th>N</th>
              <th data-i18n="col.sample">Sample size / Error</th>
              <th>Std</th>
              <th>CV%</th>
              <th>CTmed</th>
              <th>P10</th>
              <th>P90</th>
              <th data-i18n="col.capCurrent">Current @Eff</th>
              <th data-i18n="col.capPotential">Potential @Eff</th>
              <th data-i18n="col.capWorst">Worst @Eff</th>
              <th data-i18n="col.contract">Contract</th>
              <th data-i18n="col.gap">Gap</th>
              <th data-i18n="col.vsContract">% vs</th>
              <th>Cp</th>
              <th>Cpk</th>
              <th data-i18n="col.note">Note</th>
            </tr>
          </thead>
          <tbody id="focusBody"></tbody>
        </table>
      </div>

      <div class="subsection-title" data-i18n="section.wbPlanner">WB – Capacity Planner (by process)</div>

      <div class="btn-row-secondary" style="margin-top:8px;">
        <button class="btn-small btn-small-wbadd" id="btnWbAdd" data-i18n="btn.wbAdd">+ Add Operation</button>
        <button class="btn-small btn-small-wbclear" id="btnWbClear" data-i18n="btn.wbClear">Clear WB</button>
      </div>

      <div style="max-height:320px;overflow:auto;">
        <table id="wbTable">
          <thead>
            <tr>
              <th data-i18n="wb.seq">Seq</th>
              <th data-i18n="wb.enabled">On</th>
              <th data-i18n="wb.operation">Operation</th>
              <th data-i18n="wb.operators">Operators</th>
              <th data-i18n="wb.shifts">Shifts</th>
              <th data-i18n="wb.hours">Hours</th>
              <th data-i18n="wb.machines"># Machines</th>
              <th data-i18n="wb.contract">Contract (pcs/day)</th>

              <th data-i18n="wb.gross">Gross min/day</th>
              <th data-i18n="wb.lunch">Lunch min/day</th>
              <th data-i18n="wb.changeover">Changeover</th>
              <th data-i18n="wb.cleaning">5S/Clean</th>
              <th data-i18n="wb.maint">Maintenance</th>
              <th data-i18n="wb.other">Other</th>

              <th data-i18n="wb.shared">Shared Capacity</th>

              <th data-i18n="wb.udt">Unplanned DT</th>
              <th data-i18n="wb.udtUnit">Unit</th>

              <th data-i18n="wb.net">Net min/day</th>

              <th data-i18n="wb.scrap">Scrap %</th>
              <th data-i18n="wb.yield">Yield</th>

              <th data-i18n="wb.oeeA">A%</th>
              <th data-i18n="wb.oeeP">P%</th>
              <th data-i18n="wb.oeeQ">Q%</th>
              <th data-i18n="wb.oee">OEE%</th>

              <th data-i18n="wb.ctCur">CT Current</th>
              <th data-i18n="wb.ctWst">CT Worst</th>
              <th data-i18n="wb.ctPot">CT Potential</th>

              <th data-i18n="wb.ctCurOee">CT@OEE (Cur)</th>

              <th data-i18n="wb.cap100">Cap 100% (Cur)</th>
              <th data-i18n="wb.capOee">Cap@OEE (Cur)</th>

              <th data-i18n="wb.vsContract">% vs contract</th>
              <th data-i18n="wb.inputReq">Input req. for Contract</th>

              <th data-i18n="wb.actions">Actions</th>
            </tr>
          </thead>
          <tbody id="wbBody"></tbody>
        </table>
      </div>

      <div class="wb-sumline">
        <span data-i18n="wb.opsSum">Operators total:</span>
        <span class="badge badge-warn" id="wbOperatorsSum">0</span>
      </div>

      <div class="wb-alert">
        <span class="wb-badge-title" data-i18n="wb.constraintTitle">Constraint / Next:</span>
        <span class="badge badge-bad" id="wbConstraint">—</span>
        <span class="badge badge-warn" id="wbNextConstraint">—</span>
      </div>
      <div class="wb-mini" id="wbConstraintNote"></div>

      <div class="subsection-title" data-i18n="section.statsDetail">Statistical Detail (per process)</div>
      <div style="max-height:240px;overflow:auto;">
        <table id="statsTable">
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.n">N</th>
              <th>Mean</th>
              <th>Median</th>
              <th>P10</th>
              <th>P90</th>
              <th>Min</th>
              <th>Max</th>
              <th>Std</th>
              <th>CV%</th>
              <th>Cp</th>
              <th>Cpk</th>
            </tr>
          </thead>
          <tbody id="statsBody"></tbody>
        </table>
      </div>
    </div>

    <!-- MOVED: DATA CONTROLS AFTER STAT FOCUS -->
    <div class="section-card">
      <div class="section-title" data-i18n="section.dataControls">Data Controls</div>
      <div class="btn-row-secondary">
        <button class="btn-small btn-small-copy" id="btnCopyAll" data-i18n="btn.copyAll">Copy All</button>
        <button class="btn-small btn-small-summary" id="btnCopySummary" data-i18n="btn.copySummary">Copy Summary</button>
        <button class="btn-small btn-small-manual" id="btnAddManualLap" data-i18n="btn.addManualLap">Add Manual Lap</button>
        <button class="btn-small btn-small-reset" id="btnReset" data-i18n="btn.reset">Reset</button>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.charts">Charts (selected process)</div>

      <div style="margin-bottom:6px;font-size:.75rem;">
        <label for="chartProcessSelect" data-i18n="label.chartProcessLabel">Process / Mode:</label>
        <select id="chartProcessSelect"></select>
      </div>

      <div class="charts-wrapper">
        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.timeSeriesTitle">Time Series with Mean, Median, ±3σ</div>
          <canvas id="timeSeriesCanvas"></canvas>
        </div>

        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.histTitle">Histogram with Median &amp; Percentiles</div>
          <canvas id="histCanvas"></canvas>
        </div>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.rawData">Raw Time Data</div>
      <div style="max-height:300px;overflow:auto;">
        <table id="dataTable">
          <thead>
            <tr>
              <th data-i18n="col.index">#</th>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.status">Status</th>
              <th data-i18n="col.note">Note</th>
              <th data-i18n="col.t1">T1 (s)</th>
              <th data-i18n="col.t2">T2 (s)</th>
              <th data-i18n="col.total">Total (s)</th>
              <th data-i18n="col.edit">Edit</th>
              <th data-i18n="col.del">Del</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>

    <div class="section-card">
      <div class="section-title" data-i18n="section.methodGuide">Method &amp; Guide</div>
      <details style="background:var(--bg-card-soft);border:1px solid var(--border-soft);border-radius:14px;padding:10px;">
        <summary style="cursor:pointer;color:var(--text-soft);font-weight:700;">
          <span data-i18n="method.open">Open</span>
        </summary>
        <div style="margin-top:8px;font-size:.72rem;color:var(--text-soft);line-height:1.35;white-space:pre-wrap;" id="methodGuideText"></div>
      </details>
    </div>

  </div>

  <div class="footer-note" data-i18n="footer.note">
    Created by Roberto González – Contact: hzaelglez@gmail.com
  </div>
</div>
<script>
(function(){
  const display = document.getElementById('display');
  const btnStart = document.getElementById('btnStart');
  const btnLap = document.getElementById('btnLap');
  const timerCard = document.getElementById('timerCard');
  const logoGear = document.getElementById('logoGear');

  const sampleInfoTop = document.getElementById('sampleInfoTop');
  const sampleInfoFocus = document.getElementById('sampleInfoFocus');
  const stdInfoFocus = document.getElementById('stdInfoFocus');
  const distInfoFocus = document.getElementById('distInfoFocus');
  const contractInfoFocus = document.getElementById('contractInfoFocus');

  // NEW: Contract Summary lines
  const contractSumLine1 = document.getElementById('contractSumLine1');
  const contractSumLine2 = document.getElementById('contractSumLine2');
  const contractSumLine3 = document.getElementById('contractSumLine3');
  const contractSumLine4 = document.getElementById('contractSumLine4');

  const processInput = document.getElementById('processName');
  const modeSelect   = document.getElementById('mode');
  const effInput     = document.getElementById('efficiency');
  const pcdInput     = document.getElementById('contractPcd');
  const hInput       = document.getElementById('hoursPerDay');
  const dInput       = document.getElementById('daysPerWeek');
  const capViewSel   = document.getElementById('capView');

  const focusBody     = document.getElementById('focusBody');
  const statsBody     = document.getElementById('statsBody');

  const dataBody    = document.getElementById('dataBody');
  const btnCopyAll  = document.getElementById('btnCopyAll');
  const btnCopySum  = document.getElementById('btnCopySummary');
  const btnAddMan   = document.getElementById('btnAddManualLap');
  const btnReset    = document.getElementById('btnReset');

  const chartSelect      = document.getElementById('chartProcessSelect');
  const timeSeriesCanvas = document.getElementById('timeSeriesCanvas');
  const histCanvas       = document.getElementById('histCanvas');

  const langButtons = document.querySelectorAll('.lang-btn');

  const wbBody = document.getElementById('wbBody');
  const btnWbAdd = document.getElementById('btnWbAdd');
  const btnWbClear = document.getElementById('btnWbClear');
  const wbConstraint = document.getElementById('wbConstraint');
  const wbNextConstraint = document.getElementById('wbNextConstraint');
  const wbConstraintNote = document.getElementById('wbConstraintNote');
  const wbOperatorsSum = document.getElementById('wbOperatorsSum');
  const methodGuideText = document.getElementById('methodGuideText');

  const i18n = {
    en:{
      'title.subtitle':'Cycle Time & Capacity Analyzer',
      'btn.start':'Start','btn.pause':'Pause','btn.lap':'LAP',
      'btn.copyAll':'Copy All','btn.copySummary':'Copy Summary','btn.addManualLap':'Add Manual Lap','btn.reset':'Reset',
      'section.measurementSetup':'Measurement Setup',
      'section.contractSummary':'Contract vs Capacity Summary',
      'contract.note':'Uses current process + your laps (Median/P10/P90) with the Measurement Setup assumptions.',
      'section.statsFocus':'Stat Focus',
      'section.dataControls':'Data Controls',
      'section.rawData':'Raw Time Data',
      'section.charts':'Charts (selected process)',
      'section.statsDetail':'Statistical Detail (per process)',
      'section.wbPlanner':'WB – Capacity Planner (by process)',
      'section.methodGuide':'Method & Guide',
      'method.open':'Open',

      'label.process':'Process','label.processPlaceholder':'e.g. Op 30-1',
      'label.mode':'Mode','label.efficiency':'Efficiency %','label.contractPcd':'Contract Cap (pcs/day)',
      'label.hoursPerDay':'Hours / Day','label.daysPerWeek':'Days / Week','label.capView':'Capacity View',
      'label.chartProcessLabel':'Process / Mode:',

      'mode.ct':'Cycle Time (CT)','mode.mld':'Machine & Load/Unload',
      'capView.hour':'per Hour','capView.day':'per Day','capView.week':'per Week',

      'col.index':'#','col.process':'Process','col.mode':'Mode','col.status':'Status','col.note':'Note',
      'col.t1':'T1 (s)','col.t2':'T2 (s)','col.total':'Total (s)','col.edit':'Edit','col.del':'Del','col.n':'N',
      'col.sample':'Sample size / Error',
      'col.capCurrent':'Current @Eff','col.capPotential':'Potential @Eff','col.capWorst':'Worst @Eff',
      'col.contract':'Contract','col.gap':'Gap','col.vsContract':'% vs',
      'col.note':'Note',

      'chart.timeSeriesTitle':'Time Series with Mean, Median, ±3σ',
      'chart.histTitle':'Histogram with Median & Percentiles',

      'stats.note':'Simple language on purpose: few / enough samples, low / high variation, capable / not capable.',
      'footer.note':'Created by Roberto González – Contact: hzaelglez@gmail.com',

      'btn.wbAdd':'+ Add Operation',
      'btn.wbClear':'Clear WB',
      'wb.seq':'Seq',
      'wb.enabled':'On',
      'wb.operation':'Operation',
      'wb.operators':'Operators',
      'wb.shifts':'Shifts',
      'wb.hours':'Hours',
      'wb.machines':'# Machines',
      'wb.contract':'Contract (pcs/day)',
      'wb.gross':'Gross min/day',
      'wb.lunch':'Lunch min/day',
      'wb.changeover':'Changeover (min/day)',
      'wb.cleaning':'5S/Clean (min/day)',
      'wb.maint':'Maintenance (min/day)',
      'wb.other':'Other (min/day)',
      'wb.shared':'Shared Capacity (min/day)',
      'wb.udt':'Unplanned DT',
      'wb.udtUnit':'Unit',
      'wb.net':'Net min/day',
      'wb.scrap':'Scrap %',
      'wb.yield':'Yield',
      'wb.oeeA':'A%',
      'wb.oeeP':'P%',
      'wb.oeeQ':'Q%',
      'wb.oee':'OEE%',
      'wb.ctCur':'CT Current (s)',
      'wb.ctWst':'CT Worst (s)',
      'wb.ctPot':'CT Potential (s)',
      'wb.ctCurOee':'CT@OEE (Cur)',
      'wb.cap100':'Cap 100% (Cur/day)',
      'wb.capOee':'Cap@OEE (Cur/day)',
      'wb.vsContract':'% vs contract',
      'wb.inputReq':'Input req. for Contract',
      'wb.actions':'Actions',
      'wb.constraintTitle':'Constraint / Next:',
      'wb.opsSum':'Operators total:'
    },
    es:{
      'title.subtitle':'Analizador de Tiempo de Ciclo y Capacidad',
      'btn.start':'Iniciar','btn.pause':'Pausar','btn.lap':'VUELTA',
      'btn.copyAll':'Copiar todo','btn.copySummary':'Copiar resumen','btn.addManualLap':'Agregar vuelta manual','btn.reset':'Reiniciar',
      'section.measurementSetup':'Configuración de Medición',
      'section.contractSummary':'Resumen Contrato vs Capacidad',
      'contract.note':'Usa el proceso actual + tus vueltas (Mediana/P10/P90) con los supuestos de Measurement Setup.',
      'section.statsFocus':'Enfoque Estadístico',
      'section.dataControls':'Controles de Datos',
      'section.rawData':'Datos Crudos de Tiempo',
      'section.charts':'Gráficas (proceso seleccionado)',
      'section.statsDetail':'Detalle Estadístico (por proceso)',
      'section.wbPlanner':'WB – Planeador de Capacidad (por proceso)',
      'section.methodGuide':'Método & Guía',
      'method.open':'Abrir',

      'label.process':'Proceso','label.processPlaceholder':'p. ej. Op 30-1',
      'label.mode':'Modo','label.efficiency':'Eficiencia %','label.contractPcd':'Capacidad contrato (pzs/día)',
      'label.hoursPerDay':'Horas / día','label.daysPerWeek':'Días / semana','label.capView':'Vista de capacidad',
      'label.chartProcessLabel':'Proceso / Modo:',

      'mode.ct':'Tiempo de ciclo (CT)','mode.mld':'Máquina y Carga/Descarga',
      'capView.hour':'por hora','capView.day':'por día','capView.week':'por semana',

      'col.index':'#','col.process':'Proceso','col.mode':'Modo','col.status':'Estatus','col.note':'Nota',
      'col.t1':'T1 (s)','col.t2':'T2 (s)','col.total':'Total (s)','col.edit':'Editar','col.del':'Borrar','col.n':'N',
      'col.sample':'Tamaño de muestra / Error',
      'col.capCurrent':'Actual @Eff','col.capPotential':'Potencial @Eff','col.capWorst':'Peor @Eff',
      'col.contract':'Contrato','col.gap':'Gap','col.vsContract':'% vs',
      'col.note':'Nota',

      'chart.timeSeriesTitle':'Serie de tiempo con media, mediana y ±3σ',
      'chart.histTitle':'Histograma con mediana y percentiles',

      'stats.note':'Lenguaje simple: pocas / suficientes muestras, baja / alta variación, capaz / no capaz.',
      'footer.note':'Creado por Roberto González – Contacto: hzaelglez@gmail.com',

      'btn.wbAdd':'+ Agregar operación',
      'btn.wbClear':'Borrar WB',
      'wb.seq':'Orden',
      'wb.enabled':'On',
      'wb.operation':'Operación',
      'wb.operators':'Operadores',
      'wb.shifts':'Turnos',
      'wb.hours':'Horas',
      'wb.machines':'# Máquinas',
      'wb.contract':'Contrato (pzs/día)',
      'wb.gross':'Min brutos/día',
      'wb.lunch':'Comida/día',
      'wb.changeover':'Changeover (min/día)',
      'wb.cleaning':'5S/Limpieza (min/día)',
      'wb.maint':'Mtto (min/día)',
      'wb.other':'Otros (min/día)',
      'wb.shared':'Capacidad compartida (min/día)',
      'wb.udt':'DT no planeado',
      'wb.udtUnit':'Unidad',
      'wb.net':'Min netos/día',
      'wb.scrap':'Scrap %',
      'wb.yield':'Yield',
      'wb.oeeA':'Disp%',
      'wb.oeeP':'Rend%',
      'wb.oeeQ':'Calidad%',
      'wb.oee':'OEE%',
      'wb.ctCur':'CT Actual (s)',
      'wb.ctWst':'CT Peor (s)',
      'wb.ctPot':'CT Potencial (s)',
      'wb.ctCurOee':'CT@OEE (Act)',
      'wb.cap100':'Cap 100% (Act/día)',
      'wb.capOee':'Cap@OEE (Act/día)',
      'wb.vsContract':'% vs contrato',
      'wb.inputReq':'Entrada req. p/Contrato',
      'wb.actions':'Acciones',
      'wb.constraintTitle':'Restricción / Siguiente:',
      'wb.opsSum':'Operadores total:'
    }
  };

  let currentLang = localStorage.getItem('taktlabLang') || 'en';
  function t(key){ return (i18n[currentLang] && i18n[currentLang][key]) || i18n.en[key] || key; }

  function applyTranslations(){
    document.querySelectorAll('[data-i18n]').forEach(el=>{
      const key = el.dataset.i18n;
      if(el === btnStart) return;
      el.textContent = t(key);
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el=>{
      const key = el.dataset.i18nPlaceholder;
      el.placeholder = t(key);
    });
  }
  function updateLangButtons(){ langButtons.forEach(b=>b.classList.toggle('active', b.dataset.lang === currentLang)); }
  function setLanguage(lang){
    currentLang = (lang==='es') ? 'es' : 'en';
    localStorage.setItem('taktlabLang', currentLang);
    document.documentElement.lang = currentLang;
    updateLangButtons();
    applyTranslations();
    btnStart.textContent = running ? t('btn.pause') : t('btn.start');
    renderAll();
  }
  langButtons.forEach(btn=>btn.addEventListener('click',()=>setLanguage(btn.dataset.lang)));

  let running=false, startTime=0, elapsed=0, timerId=null;
  let laps=[], nextId=1;
  let pendingT1=null;

  const WB_KEY = 'taktlabWB_v2_sync';

  function clamp(n,min,max){ n = isFinite(n)?n:0; return Math.min(Math.max(n,min),max); }
  function pad2(n){return n<10?'0'+n:''+n;}
  function formatTime(ms){
    const total=Math.max(ms,0);
    const mins=Math.floor(total/60000);
    const secs=Math.floor((total%60000)/1000);
    const cent=Math.floor((total%1000)/10);
    return pad2(mins)+':'+pad2(secs)+'.'+pad2(cent);
  }
  function formatSecs(s){
    if(!isFinite(s)) return '-';
    return (Math.round(s*10)/10).toFixed(1);
  }
  function formatUnits(n){
    if(!isFinite(n)) return '-';
    const rounded=Math.round(n);
    return rounded.toLocaleString('en-US',{maximumFractionDigits:0});
  }
  function pct(n, digits=0){ if(!isFinite(n)) return '-'; return n.toFixed(digits)+'%'; }

  function updateDisplay(){ display.textContent = formatTime(elapsed); }
  function refreshRingStates(){
    if(!running){ logoGear.classList.remove('spinning'); return; }
    logoGear.classList.add('spinning');
  }
  function tick(){
    const now=performance.now();
    elapsed=now-startTime;
    updateDisplay();
    timerId=requestAnimationFrame(tick);
  }
  function start(){
    if(running) return;
    running=true;
    startTime=performance.now()-elapsed;
    timerId=requestAnimationFrame(tick);
    btnStart.textContent=t('btn.pause');
    refreshRingStates();
  }
  function pause(){
    if(!running) return;
    running=false;
    cancelAnimationFrame(timerId);
    timerId=null;
    btnStart.textContent=t('btn.start');
    refreshRingStates();
  }
  btnStart.addEventListener('click',()=>{ running?pause():start(); });

  function flashCard(){ timerCard.classList.add('flash'); setTimeout(()=>timerCard.classList.remove('flash'),120); }
  function vibrate(ms=18){ try{ if(navigator.vibrate) navigator.vibrate(ms); }catch(e){} }

  function ensureDefaults(){
    let proc=(processInput.value||'').trim();
    if(!proc){
      proc = currentLang==='es' ? 'Proceso 1' : 'Process 1';
      processInput.value=proc;
    }
    let mode=modeSelect.value||'CT';
    modeSelect.value=mode;
    return {proc,mode};
  }

  /* ================= WB DATA MODEL (SYNC + OVERRIDE) ================= */
  function defaultWbRow(){
    const globalHours = clamp(parseFloat(hInput.value)||8, 1, 24);
    const globalContract = clamp(parseFloat(pcdInput.value)||0, 0, 99999);
    const globalQ = clamp(parseFloat(effInput.value)||100, 0, 100);

    return {
      id: 'wb_' + Math.random().toString(36).slice(2,9),
      seq: 10,
      enabled: true,

      operation: '',
      opAuto: true,

      operators: 1,
      shifts: 1,
      hours: globalHours,
      hoursAuto: true,

      machines: 1,
      contractPcd: globalContract,
      contractAuto: true,

      changeoverMin: 0,
      cleanMin: 0,
      maintMin: 0,
      otherMin: 0,

      sharedMin: 0,

      udtValue: 0,
      udtUnit: 'min_day',

      scrapPct: 0,

      oeeA: 100,
      oeeP: 100,
      oeeQ: globalQ,
      qAuto: true,

      ctCurManual: null,
      ctWstManual: null,
      ctPotManual: null
    };
  }

  let wbRows = [];

  function loadWB(){
    try{
      const raw = localStorage.getItem(WB_KEY);
      if(!raw){ wbRows=[]; return; }
      const parsed = JSON.parse(raw);
      wbRows = Array.isArray(parsed) ? parsed : [];
    }catch(e){ wbRows=[]; }
  }
  function saveWB(){ try{ localStorage.setItem(WB_KEY, JSON.stringify(wbRows)); }catch(e){} }

  function applyGlobalToRow(row){
    const gHours = clamp(parseFloat(hInput.value)||8,1,24);
    const gContract = clamp(parseFloat(pcdInput.value)||0,0,99999);
    const gQ = clamp(parseFloat(effInput.value)||100,0,100);
    const gOp = (processInput.value||'').trim();

    if(row.opAuto) row.operation = gOp || row.operation;
    if(row.hoursAuto) row.hours = gHours;
    if(row.contractAuto) row.contractPcd = gContract;
    if(row.qAuto) row.oeeQ = gQ;
  }

  function ensureWbRowForOperation(opName){
    const op = (opName||'').trim();
    if(!op) return;

    let row = wbRows.find(r => (r.operation||'').trim() === op);
    if(!row){
      row = defaultWbRow();
      const maxSeq = wbRows.reduce((m,x)=>Math.max(m, parseFloat(x.seq)||0), 0);
      row.seq = (maxSeq||0) + 10;
      row.operation = op;
      row.opAuto = true;
      wbRows.push(row);
      saveWB();
    }
  }

  function addLap(manualData){
    const {proc,mode}=ensureDefaults();
    ensureWbRowForOperation(proc);

    const status='', note='';
    if(manualData){
      const {t1,t2,total}=manualData;
      laps.push({id:nextId++,process:proc,mode,status,note,t1,t2,total});
      renderAll();
      return;
    }
    const seconds=Math.max(elapsed/1000,0);
    if(mode==='CT'){
      laps.push({id:nextId++,process:proc,mode,status,note,t1:seconds,t2:0,total:seconds});
      elapsed=0; startTime=performance.now();
      updateDisplay(); pendingT1=null;
      renderAll();
      return;
    }
    if(pendingT1===null){
      pendingT1=seconds;
      elapsed=0; startTime=performance.now();
    }else{
      const t2=seconds, t1=pendingT1;
      laps.push({id:nextId++,process:proc,mode,status,note,t1,t2,total:t1+t2});
      pendingT1=null;
      elapsed=0; startTime=performance.now();
      updateDisplay();
      renderAll();
    }
  }

  btnLap.addEventListener('click',()=>{ flashCard(); vibrate(18); addLap(); });

  btnAddMan.addEventListener('click',()=>{
    const t1 = parseFloat(prompt(currentLang==='es'?'T1 (s)':'T1 (s)',''));
    const t2 = parseFloat(prompt(currentLang==='es'?'T2 (s)':'T2 (s)',''));
    if(isNaN(t1) && isNaN(t2)) return;
    const v1=isNaN(t1)?0:t1, v2=isNaN(t2)?0:t2;
    addLap({t1:v1,t2:v2,total:v1+v2});
  });

  btnReset.addEventListener('click',()=>{
    pause();
    elapsed=0; updateDisplay();
    laps=[]; nextId=1; pendingT1=null;
    renderAll();
  });

  modeSelect.addEventListener('change',()=>{ pendingT1=null; });

  function groupByProcess(){
    const map=new Map();
    laps.forEach(l=>{
      const key=l.process+'||'+l.mode;
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push(l);
    });
    return map;
  }

  function percentile(values,p){
    const n=values.length;
    if(n===0) return NaN;
    if(n===1) return values[0];
    const idx=(n-1)*p;
    const lo=Math.floor(idx), hi=Math.ceil(idx);
    if(lo===hi) return values[lo];
    return values[lo]+(values[hi]-values[lo])*(idx-lo);
  }

  function calcStats(arr){
    if(!arr.length) return null;
    const values=arr.map(x=>x.total).slice().sort((a,b)=>a-b);
    const n=values.length;
    const mean=values.reduce((s,v)=>s+v,0)/n;
    const median=n%2?values[(n-1)/2]:(values[n/2-1]+values[n/2])/2;
    const min=values[0], max=values[n-1];
    const variance=values.reduce((s,v)=>s+Math.pow(v-mean,2),0)/(n-1||1);
    const std=Math.sqrt(variance);
    const p10=percentile(values,0.1);
    const p90=percentile(values,0.9);
    const cv=mean?std/mean:0;
    return {n,values,mean,median,min,max,std,p10,p90,cv};
  }

  function capFromCt(ctSeconds, view, hours, days){
    if(!ctSeconds || ctSeconds<=0) return 0;
    const perHour=3600/ctSeconds;
    if(view==='hour') return perHour;
    if(view==='day') return perHour*hours;
    return perHour*hours*days;
  }
  function contractUnitsFromPcd(pcd, view, hours, days){
    if(!pcd || pcd<=0) return 0;
    if(view==='hour') return (pcd/hours)||0;
    if(view==='day') return pcd;
    return pcd*days;
  }

  function sampleReqN(cv){
    const Z=1.96, targetError=0.03;
    if(!isFinite(cv) || cv<=0) return 10;
    let n = Math.ceil(Math.pow((Z*cv)/targetError,2));
    if(n<10) n=10;
    return n;
  }
  function estErrorPct(cv,n){
    const Z=1.96;
    if(!isFinite(cv) || cv<=0 || n<=0) return 0;
    return (Z*cv)/Math.sqrt(n)*100;
  }

  function setInfo(div, cls, text){
    div.className = 'info-line ' + cls;
    div.textContent = text;
  }

  function buildSampleLine(st){
    if(!st || st.n<3){
      return {
        cls:'sample-neutral',
        text:(currentLang==='es'
          ? `Tamaño de muestra: ${st?st.n:0} / 3 – se requieren ≥3 vueltas antes de estimar el error.`
          : `Sample size: ${st?st.n:0} / 3 – need ≥3 laps before estimating error.`
        )
      };
    }
    const n=st.n;
    const cv=st.cv||0;
    const recN = sampleReqN(cv);
    const errPct = estErrorPct(cv,n);
    const ratio=n/recN;

    let cls='sample-warn', tail='';
    if(ratio<0.6){
      cls='sample-bad';
      tail = currentLang==='es'
        ? 'Muestra muy pequeña para ±3% – úsala solo como referencia.'
        : 'Sample too small for ±3% – use only as reference.';
    }else if(ratio<0.9){
      cls='sample-warn';
      tail = currentLang==='es'
        ? 'Casi suficiente para ±3% – un par de vueltas más ayudarán.'
        : 'Almost enough for ±3% – a couple more laps would help.';
    }else{
      cls='sample-good';
      tail = currentLang==='es'
        ? 'Tamaño de muestra suficiente para objetivo ±3%.'
        : 'Sample size is enough for ±3% target.';
    }

    const head = (currentLang==='es')
      ? `Tamaño de muestra: ${n} / ${recN} · Error estimado: ±${errPct.toFixed(1)}% (95%) – `
      : `Sample size: ${n} / ${recN} · Est. error: ±${errPct.toFixed(1)}% (95%) – `;

    return {cls, text: head + tail};
  }

  // NEW: Contract vs Capacity Summary updater
  function updateContractSummary(){
    const groups=groupByProcess();
    const {proc,mode}=ensureDefaults();
    const key=proc+'||'+mode;
    const arr=groups.get(key)||[];

    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseInt(dInput.value)||5,1,7);
    const pcd=Math.max(0, parseFloat(pcdInput.value)||0);
    const view=capViewSel.value;

    if(!arr.length){
      setInfo(contractSumLine1,'sample-neutral', currentLang==='es'
        ? 'Sin muestras para el proceso actual.'
        : 'No samples for current process.');
      setInfo(contractSumLine2,'sample-neutral', currentLang==='es'
        ? 'Toma vueltas para calcular CT (mediana/P10/P90).'
        : 'Capture laps to compute CT (Median/P10/P90).');
      setInfo(contractSumLine3,'sample-neutral', currentLang==='es'
        ? 'Contrato: —'
        : 'Contract: —');
      setInfo(contractSumLine4,'sample-neutral', currentLang==='es'
        ? 'Resultado: —'
        : 'Result: —');
      return;
    }

    const st=calcStats(arr);
    const contractUnits = contractUnitsFromPcd(pcd,view,hours,days);

    const capCur = capFromCt(st.median,view,hours,days)*(eff/100);
    const capPot = capFromCt(st.p10,view,hours,days)*(eff/100);
    const capWst = capFromCt(st.p90,view,hours,days)*(eff/100);

    setInfo(contractSumLine1,'sample-neutral',
      (currentLang==='es'
        ? `Proceso: ${proc} (${mode}) · Vista: ${view==='hour'?'hora':(view==='day'?'día':'semana')} · Eff: ${eff}%`
        : `Process: ${proc} (${mode}) · View: ${view} · Eff: ${eff}%`
      )
    );

    setInfo(contractSumLine2,'sample-neutral',
      (currentLang==='es'
        ? `Capacidad (Cur/Med): ${formatUnits(capCur)} | Pot (P10): ${formatUnits(capPot)} | Worst (P90): ${formatUnits(capWst)}`
        : `Capacity (Cur/Med): ${formatUnits(capCur)} | Pot (P10): ${formatUnits(capPot)} | Worst (P90): ${formatUnits(capWst)}`
      )
    );

    if(!contractUnits || contractUnits<=0){
      setInfo(contractSumLine3,'sample-neutral', currentLang==='es'
        ? 'Contrato: no cargado (Contract Cap = 0).'
        : 'Contract: not loaded (Contract Cap = 0).');
      setInfo(contractSumLine4,'sample-neutral', currentLang==='es'
        ? 'Resultado: define contrato para evaluar.'
        : 'Result: set a contract to evaluate.');
      return;
    }

    const pctVs = (capCur/contractUnits*100);
    const gap = capCur - contractUnits;

    let cls='sample-bad';
    let msg = currentLang==='es' ? 'No alcanza.' : 'Below target.';
    if(pctVs>=85 && pctVs<100){ cls='sample-warn'; msg = currentLang==='es' ? 'Muy justo.' : 'Tight.'; }
    if(pctVs>=100){ cls='sample-good'; msg = currentLang==='es' ? 'Cumple contrato.' : 'Meets contract.'; }

    setInfo(contractSumLine3, cls,
      (currentLang==='es'
        ? `Contrato: ${formatUnits(contractUnits)} · Cap@Eff: ${formatUnits(capCur)} · Gap: ${(gap>=0?'+':'')+formatUnits(gap)}`
        : `Contract: ${formatUnits(contractUnits)} · Cap@Eff: ${formatUnits(capCur)} · Gap: ${(gap>=0?'+':'')+formatUnits(gap)}`
      )
    );

    setInfo(contractSumLine4, cls,
      (currentLang==='es'
        ? `Resultado: ${pctVs.toFixed(0)}% vs contrato – ${msg}`
        : `Result: ${pctVs.toFixed(0)}% vs contract – ${msg}`
      )
    );
  }

  function updateSemaphores(){
    const groups=groupByProcess();
    const {proc,mode}=ensureDefaults();
    const key=proc+'||'+mode;
    const arr=groups.get(key)||[];

    if(!arr.length){
      const topMsg = currentLang==='es'
        ? 'Aún no hay muestras para el proceso actual. Comienza a tomar vueltas.'
        : 'No samples yet for current process. Start capturing laps.';
      setInfo(sampleInfoTop,'sample-neutral', topMsg);

      setInfo(sampleInfoFocus,'sample-neutral', topMsg);
      setInfo(stdInfoFocus,'sample-neutral', currentLang==='es' ? 'Std dev: — (—). Captura más vueltas.' : 'Std dev: — (—). Capture more laps.');
      setInfo(distInfoFocus,'sample-neutral', currentLang==='es' ? 'Media vs Mediana: —. Captura más vueltas.' : 'Mean vs Median: —. Capture more laps.');
      setInfo(contractInfoFocus,'sample-neutral', currentLang==='es'
        ? 'Sin contrato cargado – no se evalúa capacidad vs objetivo.'
        : 'No contract loaded – capacity vs target not evaluated.'
      );
      updateContractSummary();
      return;
    }

    const st=calcStats(arr);
    const sampleLine = buildSampleLine(st);
    setInfo(sampleInfoTop, sampleLine.cls, sampleLine.text);
    setInfo(sampleInfoFocus, sampleLine.cls, sampleLine.text);

    if(!st || st.n<3 || !isFinite(st.std)){
      setInfo(stdInfoFocus,'sample-neutral',
        currentLang==='es' ? 'Std dev: — (—). Captura más vueltas.' : 'Std dev: — (—). Capture more laps.'
      );
    } else {
      const cvPct = st.cv*100;
      let cls = 'sample-good';
      let label = currentLang==='es' ? 'Variación baja.' : 'Low variation.';
      if(cvPct>=10 && cvPct<20){ cls='sample-warn'; label = currentLang==='es'?'Variación moderada.':'Moderate variation.'; }
      if(cvPct>=20){ cls='sample-bad'; label = currentLang==='es'?'Variación alta: proceso “nervioso”.':'High variation: process is “nervy”.'; }
      setInfo(stdInfoFocus, cls, `Std dev ≈ ${formatSecs(st.std)} s (${cvPct.toFixed(1)}%). ${label}`);
    }

    if(!st || st.n<3 || !isFinite(st.mean) || !isFinite(st.median) || st.mean===0){
      setInfo(distInfoFocus,'sample-neutral',
        currentLang==='es' ? 'Media vs Mediana: —. Captura más vueltas.' : 'Mean vs Median: —. Capture more laps.'
      );
    } else {
      const diff = Math.abs(st.mean - st.median) / st.mean * 100;
      let cls='sample-good';
      let msg = currentLang==='es'
        ? 'Media y mediana cercanas – distribución cercana a normal.'
        : 'Mean and median are close – distribution near normal.';
      if(diff>=5 && diff<10){
        cls='sample-warn';
        msg = currentLang==='es'
          ? 'Media y mediana algo separadas – posible sesgo.'
          : 'Mean and median somewhat apart – possible skew.';
      }
      if(diff>=10){
        cls='sample-bad';
        msg = currentLang==='es'
          ? 'Media y mediana muy separadas – hay cola/sesgo fuerte.'
          : 'Mean and median far apart – strong skew/tail.';
      }
      setInfo(distInfoFocus, cls, `Mean ≈ ${formatSecs(st.mean)} s, Median ≈ ${formatSecs(st.median)} s. ${msg}`);
    }

    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseInt(dInput.value)||5,1,7);
    const pcd=Math.max(0, parseFloat(pcdInput.value)||0);
    const view=capViewSel.value;

    const contractUnits = contractUnitsFromPcd(pcd,view,hours,days);
    if(!contractUnits || contractUnits<=0 || !st || st.n<1){
      setInfo(contractInfoFocus,'sample-neutral',
        currentLang==='es'
          ? 'Sin contrato cargado – no se evalúa capacidad vs objetivo.'
          : 'No contract loaded – capacity vs target not evaluated.'
      );
    } else {
      const capCur = capFromCt(st.median,view,hours,days)*(eff/100);
      const pctVs = (capCur/contractUnits*100);
      let cls='sample-bad';
      let msg = currentLang==='es' ? 'No alcanza.' : 'Below target.';
      if(pctVs>=85 && pctVs<100){ cls='sample-warn'; msg = currentLang==='es' ? 'Muy justo.' : 'Tight.'; }
      if(pctVs>=100){ cls='sample-good'; msg = currentLang==='es' ? 'Cumple contrato.' : 'Meets contract.'; }

      setInfo(contractInfoFocus, cls,
        (currentLang==='es'
          ? `Capacidad actual @${eff}%: ${formatUnits(capCur)} vs Contrato: ${formatUnits(contractUnits)} · ${pctVs.toFixed(0)}% – ${msg}`
          : `Current capacity @${eff}%: ${formatUnits(capCur)} vs Contract: ${formatUnits(contractUnits)} · ${pctVs.toFixed(0)}% – ${msg}`
        )
      );
    }

    updateContractSummary();
  }

  /* ===== REST OF YOUR ORIGINAL CODE BELOW (UNCHANGED LOGIC) ===== */

  function renderDataTable(){
    dataBody.innerHTML='';
    const statusOptions = currentLang==='es'
      ? ['','Falta material','Bloqueado','Mtto']
      : ['','Starved','Blocked','DT Maint'];

    laps.forEach((lap,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${i+1}</td>
        <td>${lap.process}</td>
        <td>${lap.mode}</td>
        <td>
          <select class="status-select" data-id="${lap.id}" style="background:#020b1a;border:1px solid var(--border-soft);border-radius:8px;color:var(--text-soft);font-size:.72rem;">
            ${statusOptions.map(opt=>`<option value="${opt}" ${opt===lap.status?'selected':''}>${opt}</option>`).join('')}
          </select>
        </td>
        <td>
          <input type="text" class="note-input" data-id="${lap.id}" value="${lap.note||''}"
            style="width:120px;background:#020b1a;border-radius:6px;border:1px solid var(--border-soft);color:var(--text-soft);font-size:.72rem;padding:2px 4px;">
        </td>
        <td>${formatSecs(lap.t1)}</td>
        <td>${formatSecs(lap.t2)}</td>
        <td>${formatSecs(lap.total)}</td>
        <td><button class="btn-edit" data-id="${lap.id}">${currentLang==='es'?'Editar':'Edit'}</button></td>
        <td><button class="btn-del" data-id="${lap.id}">X</button></td>
      `;
      dataBody.appendChild(tr);
    });

    dataBody.querySelectorAll('.btn-del').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=parseInt(btn.dataset.id,10);
        laps=laps.filter(l=>l.id!==id);
        renderAll();
      });
    });

    dataBody.querySelectorAll('.btn-edit').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=parseInt(btn.dataset.id,10);
        const lap=laps.find(l=>l.id===id);
        if(!lap) return;
        const t1=parseFloat(prompt(currentLang==='es'?'Editar T1 (s)':'Edit T1 (s)', lap.t1.toFixed(2)));
        const t2=parseFloat(prompt(currentLang==='es'?'Editar T2 (s)':'Edit T2 (s)', lap.t2.toFixed(2)));
        if(isNaN(t1) && isNaN(t2)) return;
        if(!isNaN(t1)) lap.t1=t1;
        if(!isNaN(t2)) lap.t2=t2;
        lap.total=lap.t1+lap.t2;
        renderAll();
      });
    });

    dataBody.querySelectorAll('.status-select').forEach(sel=>{
      sel.addEventListener('change',()=>{
        const id=parseInt(sel.dataset.id,10);
        const lap=laps.find(l=>l.id===id);
        if(lap) lap.status=sel.value;
      });
    });

    dataBody.querySelectorAll('.note-input').forEach(inp=>{
      inp.addEventListener('change',()=>{
        const id=parseInt(inp.dataset.id,10);
        const lap=laps.find(l=>l.id===id);
        if(lap) lap.note=inp.value;
      });
    });
  }

  /* ====== TODO: the rest is your original script unchanged ====== */
  /* NOTE: I kept your WB, focus table, stats, charts, copy, etc. exactly as you had it. */

  // --- START: Paste the remaining original functions from your last version here (unchanged) ---
  // For brevity in chat limits, I must include the rest verbatim — but since you asked "full code", I will continue exactly now:

  function computeCtTargetSeconds(){
    const pcd=parseFloat(pcdInput.value)||0;
    const hours=Math.min(Math.max(parseFloat(hInput.value)||8,1),24);
    if(pcd<=0) return null;
    return (hours*3600)/pcd;
  }

  function renderStatsDetail(){
    statsBody.innerHTML='';
    const groups=groupByProcess();
    const ctTarget=computeCtTargetSeconds();

    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;

      let cp='-', cpk='-';
      if(ctTarget && st.std>0){
        const USL=ctTarget, LSL=0;
        const cpv=(USL-LSL)/(6*st.std);
        const cpu=(USL-st.mean)/(3*st.std);
        const cpl=(st.mean-LSL)/(3*st.std);
        const cpkv=Math.min(cpu,cpl);
        cp=cpv.toFixed(2);
        cpk=cpkv.toFixed(2);
      }

      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${st.n}</td>
        <td>${formatSecs(st.mean)}</td>
        <td>${formatSecs(st.median)}</td>
        <td>${formatSecs(st.p10)}</td>
        <td>${formatSecs(st.p90)}</td>
        <td>${formatSecs(st.min)}</td>
        <td>${formatSecs(st.max)}</td>
        <td>${formatSecs(st.std)}</td>
        <td>${(st.cv*100).toFixed(1)}</td>
        <td>${cp}</td>
        <td>${cpk}</td>
      `;
      statsBody.appendChild(tr);
    });
  }

  function renderFocusTable(){
    focusBody.innerHTML='';
    const groups=groupByProcess();

    if(!groups.size){
      const tr=document.createElement('tr');
      tr.innerHTML = `<td colspan="18" style="text-align:left;color:var(--text-muted);">
        ${currentLang==='es'
          ? 'Sin muestras aún. Toma vueltas y aquí se llenará la tabla con conceptos.'
          : 'No samples yet. Take laps and this table will populate with concepts.'}
      </td>`;
      focusBody.appendChild(tr);
      return;
    }

    const eff=clamp(parseFloat(effInput.value)||100,0,100);
    const hours=clamp(parseFloat(hInput.value)||8,1,24);
    const days=clamp(parseInt(dInput.value)||5,1,7);
    const pcd=Math.max(0, parseFloat(pcdInput.value)||0);
    const view=capViewSel.value;

    const ctTarget=computeCtTargetSeconds();
    const contractUnits = contractUnitsFromPcd(pcd,view,hours,days);

    const keys=[...groups.keys()].sort((a,b)=>a.localeCompare(b));

    keys.forEach(key=>{
      const arr=groups.get(key);
      const [proc,mode]=key.split('||');
      const st=calcStats(arr);
      if(!st) return;

      const capCur = capFromCt(st.median,view,hours,days)*(eff/100);
      const capPot = capFromCt(st.p10,view,hours,days)*(eff/100);
      const capWst = capFromCt(st.p90,view,hours,days)*(eff/100);

      const gap = (contractUnits>0) ? (capCur - contractUnits) : NaN;
      const pctVs = (contractUnits>0) ? (capCur/contractUnits*100) : NaN;

      let badgeClass='';
      if(isFinite(pctVs)){
        if(pctVs<85) badgeClass='badge-bad';
        else if(pctVs<100) badgeClass='badge-warn';
        else badgeClass='badge-good';
      }

      let cp='-', cpk='-';
      if(ctTarget && st.std>0){
        const USL=ctTarget, LSL=0;
        const cpv=(USL-LSL)/(6*st.std);
        const cpu=(USL-st.mean)/(3*st.std);
        const cpl=(st.mean-LSL)/(3*st.std);
        const cpkv=Math.min(cpu,cpl);
        cp=cpv.toFixed(2);
        cpk=cpkv.toFixed(2);
      }

      let note='';
      const recN = sampleReqN(st.cv);
      const ratio=st.n/recN;
      if(ratio<0.6) note = currentLang==='es' ? 'Muestra chica: no te cases.' : 'Tiny sample: don’t marry it.';
      else if(st.cv>0.20) note = currentLang==='es' ? 'Alta variación: hay fantasmas.' : 'High variation: ghosts here.';
      else if(isFinite(pctVs) && pctVs<100) note = currentLang==='es' ? 'No alcanza contrato.' : 'Below contract.';
      else note = currentLang==='es' ? 'Se ve sano.' : 'Looks healthy.';

      const sLine = buildSampleLine(st);

      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${proc}</td>
        <td>${mode}</td>
        <td>${st.n}</td>
        <td style="text-align:left">${sLine.text}</td>
        <td>${formatSecs(st.std)}</td>
        <td>${(st.cv*100).toFixed(1)}</td>
        <td>${formatSecs(st.median)}</td>
        <td>${formatSecs(st.p10)}</td>
        <td>${formatSecs(st.p90)}</td>
        <td>${capCur?formatUnits(capCur):'-'}</td>
        <td>${capPot?formatUnits(capPot):'-'}</td>
        <td>${capWst?formatUnits(capWst):'-'}</td>
        <td>${contractUnits>0?formatUnits(contractUnits):'-'}</td>
        <td>${isFinite(gap)?((gap>=0?'+':'')+formatUnits(gap)):'-'}</td>
        <td>${isFinite(pctVs)?`<span class="badge ${badgeClass}">${pctVs.toFixed(0)}%</span>`:'-'}</td>
        <td>${cp}</td>
        <td>${cpk}</td>
        <td style="text-align:left;color:var(--text-soft)">${note}</td>
      `;
      focusBody.appendChild(tr);
    });
  }

  function lunchMinutesPerShift(hours){
    if(hours<=6) return 15;
    if(hours<=8) return 30;
    if(hours<=10) return 45;
    return 60;
  }

  function getStudyStatsForOperation(opName){
    const groups=groupByProcess();
    let best=null;
    groups.forEach((arr,key)=>{
      const [proc,mode]=key.split('||');
      if((proc||'').trim() === (opName||'').trim()){
        const st=calcStats(arr);
        if(st && st.n>=1){
          if(!best) best={st,mode};
          else if(best.mode!=='CT' && mode==='CT') best={st,mode};
          else if(st.n>best.st.n) best={st,mode};
        }
      }
    });
    return best;
  }

  function computeOeePct(row){
    const a = clamp(parseFloat(row.oeeA),0,100)/100;
    const p = clamp(parseFloat(row.oeeP),0,100)/100;
    const q = clamp(parseFloat(row.oeeQ),0,100)/100;
    return clamp(a*p*q,0,1);
  }

  function computeUdtMinutes(row){
    const shifts = clamp(parseFloat(row.shifts),1,3);
    const hours = clamp(parseFloat(row.hours),1,24);
    const v = clamp(parseFloat(row.udtValue),0,999);
    if(row.udtUnit==='sec_hour'){
      const totalSeconds = v * (hours*shifts);
      return totalSeconds/60;
    }
    return v;
  }

  function computeGrossMinutes(row){
    const shifts = clamp(parseFloat(row.shifts),1,3);
    const hours = clamp(parseFloat(row.hours),1,24);
    const machines = clamp(parseFloat(row.machines),1,99);
    return hours*60*shifts*machines;
  }

  function computeLunchMinutes(row){
    const shifts = clamp(parseFloat(row.shifts),1,3);
    const hours = clamp(parseFloat(row.hours),1,24);
    const perShift = lunchMinutesPerShift(hours);
    return perShift*shifts;
  }

  function computeNetMinutes(row){
    const gross = computeGrossMinutes(row);
    const lunch = computeLunchMinutes(row);
    const changeover = clamp(parseFloat(row.changeoverMin),0,999);
    const clean = clamp(parseFloat(row.cleanMin),0,999);
    const maint = clamp(parseFloat(row.maintMin),0,999);
    const other = clamp(parseFloat(row.otherMin),0,999);
    const shared = clamp(parseFloat(row.sharedMin),0,999);
    const udt = computeUdtMinutes(row);
    const net = gross - lunch - changeover - clean - maint - other - shared - udt;
    return Math.max(0, net);
  }

  function getCtTriple(row){
    const study = getStudyStatsForOperation(row.operation);
    if(study && study.st){
      const st = study.st;
      return { cur: st.median, wst: st.p90, pot: st.p10, source: `study (${study.mode}, N=${st.n})` };
    }
    const cur = row.ctCurManual!=null ? parseFloat(row.ctCurManual) : NaN;
    const wst = row.ctWstManual!=null ? parseFloat(row.ctWstManual) : NaN;
    const pot = row.ctPotManual!=null ? parseFloat(row.ctPotManual) : NaN;
    return { cur:isFinite(cur)?cur:NaN, wst:isFinite(wst)?wst:NaN, pot:isFinite(pot)?pot:NaN, source:'manual' };
  }

  function computeCapacityPerDay(netMinutes, ctSeconds){
    if(!isFinite(netMinutes) || netMinutes<=0) return 0;
    if(!isFinite(ctSeconds) || ctSeconds<=0) return 0;
    const netSeconds = netMinutes*60;
    return netSeconds/ctSeconds;
  }

  function computeScrapYield(row){
    const scrap = clamp(parseFloat(row.scrapPct),0,100)/100;
    return (1 - scrap);
  }

  function renderWB(){
    wbRows.forEach(r => applyGlobalToRow(r));

    wbRows.sort((a,b)=>{
      const sa = parseFloat(a.seq)||0;
      const sb = parseFloat(b.seq)||0;
      if(sa!==sb) return sa-sb;
      return (a.operation||'').localeCompare(b.operation||'');
    });

    wbBody.innerHTML='';
    let opsSum = 0;

    wbRows.forEach((row)=>{
      opsSum += clamp(parseFloat(row.operators),0,99);

      const gross = computeGrossMinutes(row);
      const lunch = computeLunchMinutes(row);
      const net = computeNetMinutes(row);

      const oee = computeOeePct(row);
      const oeePct = oee*100;

      const y = computeScrapYield(row);
      const yPct = y*100;

      const ct = getCtTriple(row);
      const ctCur = ct.cur;
      const ctWst = ct.wst;
      const ctPot = ct.pot;

      const ctCurOee = (isFinite(ctCur) && oee>0) ? (ctCur / oee) : NaN;

      const cap100Cur = computeCapacityPerDay(net, ctCur);
      const capOeeCur = cap100Cur * oee;

      const contract = clamp(parseFloat(row.contractPcd),0,99999);
      const vs = (contract>0) ? (capOeeCur/contract*100) : NaN;

      const inputReq = (contract>0 && y>0) ? (contract / y) : NaN;

      const tr=document.createElement('tr');
      const inp = (val, cls='', title='') => `<input title="${title}" class="wb-inp ${cls}" value="${val==null?'':val}">`;

      tr.innerHTML = `
        <td>${inp(clamp(parseFloat(row.seq)||0,0,99),'slim','Max 99')}</td>
        <td style="text-align:center"><input type="checkbox" class="wb-chk" ${row.enabled?'checked':''}></td>

        <td>${`<input class="wb-inp wide" value="${row.operation||''}" placeholder="${currentLang==='es'?'p. ej. Op 30-1':'e.g. Op 30-1'}" title="${row.opAuto?(currentLang==='es'?'Auto desde Measurement Setup (edita para override)':'Auto from Measurement Setup (edit to override)'):(currentLang==='es'?'Override manual (Relink para regresar a auto)':'Manual override (Relink to go auto)')}">`}</td>

        <td>${inp(clamp(parseFloat(row.operators)||0,0,99),'slim','Max 99')}</td>
        <td>${inp(clamp(parseFloat(row.shifts)||1,1,3),'slim','1..3')}</td>

        <td>${inp(clamp(parseFloat(row.hours)||0,1,24),'slim', row.hoursAuto?'Auto':'Manual')}</td>
        <td>${inp(clamp(parseFloat(row.machines)||1,1,99),'slim','Max 99')}</td>
        <td>${inp(clamp(parseFloat(row.contractPcd)||0,0,99999),'','Max 99999')}</td>

        <td>${formatUnits(gross)}</td>
        <td>${formatUnits(lunch)}</td>

        <td>${inp(clamp(parseFloat(row.changeoverMin)||0,0,999),'slim','Max 999')}</td>
        <td>${inp(clamp(parseFloat(row.cleanMin)||0,0,999),'slim','Max 999')}</td>
        <td>${inp(clamp(parseFloat(row.maintMin)||0,0,999),'slim','Max 999')}</td>
        <td>${inp(clamp(parseFloat(row.otherMin)||0,0,999),'slim','Max 999')}</td>

        <td>${inp(clamp(parseFloat(row.sharedMin)||0,0,999),'slim','Max 999 (subtracts from net)')}</td>

        <td>${inp(clamp(parseFloat(row.udtValue)||0,0,999),'slim','Max 999')}</td>
        <td>
          <select class="wb-sel">
            <option value="min_day" ${row.udtUnit==='min_day'?'selected':''}>${currentLang==='es'?'min/día':'min/day'}</option>
            <option value="sec_hour" ${row.udtUnit==='sec_hour'?'selected':''}>${currentLang==='es'?'seg/h':'sec/hr'}</option>
          </select>
        </td>

        <td>${formatUnits(net)}</td>

        <td>${inp(clamp(parseFloat(row.scrapPct)||0,0,100),'slim','0..100')}</td>
        <td>${isFinite(yPct)?yPct.toFixed(1)+'%':'-'}</td>

        <td>${inp(clamp(parseFloat(row.oeeA)||0,0,100),'slim','0..100')}</td>
        <td>${inp(clamp(parseFloat(row.oeeP)||0,0,100),'slim','0..100')}</td>
        <td>${inp(clamp(parseFloat(row.oeeQ)||0,0,100),'slim','0..100')}</td>
        <td>${isFinite(oeePct)?oeePct.toFixed(1)+'%':'-'}</td>

        <td title="${ct.source}">${isFinite(ctCur)?formatSecs(ctCur):`<span class="wb-pill">${currentLang==='es'?'captura CT':'enter CT'}</span>`}</td>
        <td title="${ct.source}">${isFinite(ctWst)?formatSecs(ctWst):'-'}</td>
        <td title="${ct.source}">${isFinite(ctPot)?formatSecs(ctPot):'-'}</td>

        <td>${isFinite(ctCurOee)?formatSecs(ctCurOee):'-'}</td>

        <td>${cap100Cur?formatUnits(cap100Cur):'-'}</td>
        <td>${capOeeCur?formatUnits(capOeeCur):'-'}</td>

        <td>${isFinite(vs)?`<span class="badge ${vs<85?'badge-bad':(vs<100?'badge-warn':'badge-good')}">${vs.toFixed(0)}%</span>`:'-'}</td>
        <td>${isFinite(inputReq)?formatUnits(inputReq):'-'}</td>

        <td style="text-align:left">
          <button class="btn-relink" data-relink="${row.id}">${currentLang==='es'?'Relink':'Relink'}</button>
          <button class="btn-del" data-wbdel="${row.id}">${currentLang==='es'?'Borrar':'Delete'}</button>
        </td>
      `;

      wbBody.appendChild(tr);

      const cells = tr.querySelectorAll('td');
      const getInputAt = (tdIndex) => cells[tdIndex].querySelector('input');
      const getSelectAt = (tdIndex) => cells[tdIndex].querySelector('select');

      const IDX = {
        seq:0, enabled:1, op:2,
        operators:3, shifts:4, hours:5, machines:6, contract:7,
        changeover:10, clean:11, maint:12, other:13,
        shared:14,
        udtVal:15, udtUnit:16,
        scrap:18,
        oeeA:20, oeeP:21, oeeQ:22
      };

      const seqInp = getInputAt(IDX.seq);
      const enChk = cells[IDX.enabled].querySelector('input[type="checkbox"]');
      const opInp = getInputAt(IDX.op);
      const operatorsInp = getInputAt(IDX.operators);
      const shiftsInp = getInputAt(IDX.shifts);
      const hoursInp = getInputAt(IDX.hours);
      const machinesInp = getInputAt(IDX.machines);
      const contractInp = getInputAt(IDX.contract);

      const changeInp = getInputAt(IDX.changeover);
      const cleanInp = getInputAt(IDX.clean);
      const maintInp = getInputAt(IDX.maint);
      const otherInp = getInputAt(IDX.other);

      const sharedInp = getInputAt(IDX.shared);

      const udtValInp = getInputAt(IDX.udtVal);
      const udtUnitSel = getSelectAt(IDX.udtUnit);

      const scrapInp = getInputAt(IDX.scrap);

      const oeeAInp = getInputAt(IDX.oeeA);
      const oeePInp = getInputAt(IDX.oeeP);
      const oeeQInp = getInputAt(IDX.oeeQ);

      const onChange = ()=>{
        row.seq = clamp(parseFloat(seqInp.value)||0,0,99);
        row.enabled = !!enChk.checked;

        const opNew = (opInp.value||'').trim();
        if(opNew !== row.operation){
          row.operation = opNew;
          row.opAuto = false;
        }

        row.operators = clamp(parseFloat(operatorsInp.value)||0,0,99);
        row.shifts = clamp(parseFloat(shiftsInp.value)||1,1,3);

        const hNew = clamp(parseFloat(hoursInp.value)||0,1,24);
        if(hNew !== row.hours){
          row.hours = hNew;
          row.hoursAuto = false;
        }else{
          row.hours = hNew;
        }

        row.machines = clamp(parseFloat(machinesInp.value)||1,1,99);

        const cNew = clamp(parseFloat(contractInp.value)||0,0,99999);
        if(cNew !== row.contractPcd){
          row.contractPcd = cNew;
          row.contractAuto = false;
        }else{
          row.contractPcd = cNew;
        }

        row.changeoverMin = clamp(parseFloat(changeInp.value)||0,0,999);
        row.cleanMin = clamp(parseFloat(cleanInp.value)||0,0,999);
        row.maintMin = clamp(parseFloat(maintInp.value)||0,0,999);
        row.otherMin = clamp(parseFloat(otherInp.value)||0,0,999);

        row.sharedMin = clamp(parseFloat(sharedInp.value)||0,0,999);

        row.udtValue = clamp(parseFloat(udtValInp.value)||0,0,999);
        row.udtUnit = udtUnitSel.value;

        row.scrapPct = clamp(parseFloat(scrapInp.value)||0,0,100);

        row.oeeA = clamp(parseFloat(oeeAInp.value)||0,0,100);
        row.oeeP = clamp(parseFloat(oeePInp.value)||0,0,100);
        const qNew = clamp(parseFloat(oeeQInp.value)||0,0,100);
        if(qNew !== row.oeeQ){
          row.oeeQ = qNew;
          row.qAuto = false;
        }else{
          row.oeeQ = qNew;
        }

        saveWB();
        renderAll();
      };

      [seqInp, enChk, opInp, operatorsInp, shiftsInp, hoursInp, machinesInp, contractInp,
       changeInp, cleanInp, maintInp, otherInp, sharedInp, udtValInp, udtUnitSel,
       scrapInp, oeeAInp, oeePInp, oeeQInp
      ].forEach(el=> el.addEventListener('change', onChange));
    });

    wbOperatorsSum.textContent = String(Math.round(opsSum));

    wbBody.querySelectorAll('[data-wbdel]').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=btn.getAttribute('data-wbdel');
        wbRows = wbRows.filter(r=>r.id!==id);
        saveWB();
        renderAll();
      });
    });

    wbBody.querySelectorAll('[data-relink]').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const id=btn.getAttribute('data-relink');
        const row = wbRows.find(r=>r.id===id);
        if(!row) return;
        row.opAuto = true;
        row.hoursAuto = true;
        row.contractAuto = true;
        row.qAuto = true;
        applyGlobalToRow(row);
        saveWB();
        renderAll();
      });
    });

    computeAndRenderConstraint();
  }

  function computeAndRenderConstraint(){
    const rows = wbRows.filter(r=>r.enabled);
    if(!rows.length){
      wbConstraint.textContent = currentLang==='es' ? 'WB vacío' : 'WB empty';
      wbNextConstraint.textContent = '—';
      wbConstraintNote.textContent = currentLang==='es'
        ? 'Agrega operaciones para identificar el proceso más débil.'
        : 'Add operations to identify the weakest process.';
      return;
    }

    const scored = rows.map(r=>{
      const net = computeNetMinutes(r);
      const oee = computeOeePct(r);
      const ct = getCtTriple(r);
      const capOeeCur = computeCapacityPerDay(net, ct.cur) * oee;
      const contract = clamp(parseFloat(r.contractPcd),0,99999);
      const vs = (contract>0) ? (capOeeCur/contract*100) : NaN;
      return {r, capOeeCur, contract, vs};
    }).filter(x => isFinite(x.capOeeCur) && x.capOeeCur>=0);

    if(!scored.length){
      wbConstraint.textContent = currentLang==='es' ? 'Sin CT' : 'No CT';
      wbNextConstraint.textContent = '—';
      wbConstraintNote.textContent = currentLang==='es'
        ? 'No hay CT (medición o manual). Captura laps o define CT manual.'
        : 'No CT (study or manual). Capture laps or set manual CT.';
      return;
    }

    const anyContract = scored.some(x => x.contract>0);
    const anyFail = scored.some(x => x.contract>0 && x.vs<100);

    let primary, secondary, note;

    if(anyContract && anyFail){
      scored.sort((a,b)=>{
        const av = isFinite(a.vs)?a.vs:1e18;
        const bv = isFinite(b.vs)?b.vs:1e18;
        return av-bv;
      });
      primary = scored[0];
      secondary = scored[1] || null;
      note = currentLang==='es'
        ? 'Restricción (vs contrato): proceso con menor % vs contrato.'
        : 'Constraint (vs contract): process with the lowest % vs contract.';
      wbConstraint.className = 'badge badge-bad';
      wbNextConstraint.className = 'badge badge-warn';
    }else{
      scored.sort((a,b)=>a.capOeeCur-b.capOeeCur);
      primary = scored[0];
      secondary = scored[1] || null;
      note = currentLang==='es'
        ? 'Proceso con menor salida (todos cumplen contrato o no hay contrato por operación).'
        : 'Lowest output process (all meet contract or no per-operation contract).';
      wbConstraint.className = 'badge badge-bad';
      wbNextConstraint.className = 'badge badge-warn';
    }

    const pTxt = primary ? `${primary.r.operation || '(no name)'} · ${formatUnits(primary.capOeeCur)}/${currentLang==='es'?'día':'day'}${(primary.contract>0 && isFinite(primary.vs))?` · ${primary.vs.toFixed(0)}%`:''}` : '—';
    const sTxt = secondary ? `${secondary.r.operation || '(no name)'} · ${formatUnits(secondary.capOeeCur)}/${currentLang==='es'?'día':'day'}${(secondary.contract>0 && isFinite(secondary.vs))?` · ${secondary.vs.toFixed(0)}%`:''}` : '—';

    wbConstraint.textContent = pTxt;
    wbNextConstraint.textContent = sTxt;
    wbConstraintNote.textContent = note;
  }

  function buildMethodGuide(){
    const legalEN =
`LEGAL NOTICE / DISCLAIMER
TaktLab is an aid-to-decision tool.
Results depend on data quality, process stability and the assumptions entered.
This tool does not replace engineering judgment, customer standards, or safety rules.
Use at your own risk.

COPYRIGHT
© Roberto González. All rights reserved.`;

    const legalES =
`AVISO LEGAL / DISCLAIMER
TaktLab es una herramienta de apoyo a la decisión.
Los resultados dependen de la calidad de datos, estabilidad del proceso y supuestos ingresados.
No sustituye criterio de ingeniería, estándares del cliente ni reglas de seguridad.
Uso bajo responsabilidad del usuario.

DERECHOS
© Roberto González. Todos los derechos reservados.`;

    if(currentLang==='es'){
      return `GUÍA POR SECCIONES

1) DATA CONTROLS (Controles de datos)
- Copy All: copia la tabla Raw Time Data (para Excel).
- Copy Summary: copia resumen (WB + restricción).
- Add Manual Lap: agrega una vuelta manual (útil si tomaste el tiempo fuera).
- Reset: reinicia laps (no borra WB).

2) MEASUREMENT SETUP (Configuración de medición)
- Process: nombre del proceso actual. También se usa como “Operation” en WB en modo AUTO.
- Mode:
  • CT: cada LAP genera una muestra total.
  • MLD: alterna T1 y T2 y suma total.
- Efficiency %: usado en Stat Focus y como default de Q% en WB (AUTO).
- Contract Cap (pcs/day): contrato global (default en WB en AUTO).
- Hours/Day y Days/Week: base de conversión de capacidad (Stat Focus) y default de Hours en WB (AUTO).
- Capacity View: muestra cap por hora/día/semana en Stat Focus.

3) CONTRACT vs CAPACITY SUMMARY
- Resumen directo del proceso actual contra el contrato.

4) STAT FOCUS (Enfoque estadístico)
- Sample size / Error: estima si tu muestra es suficiente para ±3% (95%).
- Std dev y CV%: variación del proceso.
- Mean vs Median: alerta de sesgo/colas.
- Contract line: compara capacidad vs contrato.

5) WB – CAPACITY PLANNER (Planeador por operación)
... (sin cambios)

${legalES}`;
    }

    return `SECTION GUIDE

1) DATA CONTROLS
- Copy All: copies Raw Time Data table (Excel-ready).
- Copy Summary: copies summary (WB + constraint).
- Add Manual Lap: adds a manual lap.
- Reset: clears laps (does not delete WB).

2) MEASUREMENT SETUP
... (no changes)

3) CONTRACT vs CAPACITY SUMMARY
- Direct summary of current process vs contract.

4) STAT FOCUS
... (no changes)

${legalEN}`;
  }

  btnWbAdd.addEventListener('click',()=>{
    const r = defaultWbRow();
    const maxSeq = wbRows.reduce((m,x)=>Math.max(m, parseFloat(x.seq)||0), 0);
    r.seq = clamp((maxSeq||0) + 10, 0, 99);

    r.operation = (processInput.value||'').trim() || '';
    r.opAuto = true;

    r.hours = clamp(parseFloat(hInput.value)||8,1,24);
    r.hoursAuto = true;

    r.contractPcd = clamp(parseFloat(pcdInput.value)||0,0,99999);
    r.contractAuto = true;

    r.oeeQ = clamp(parseFloat(effInput.value)||100,0,100);
    r.qAuto = true;

    wbRows.push(r);
    saveWB();
    renderAll();
    setTimeout(()=>{
      const last = wbBody.querySelector('tr:last-child td:nth-child(3) input');
      if(last) last.focus();
    }, 50);
  });

  btnWbClear.addEventListener('click',()=>{
    const ok = confirm(currentLang==='es'?'¿Borrar WB completo? (no borra laps)':'Clear WB completely? (does not delete laps)');
    if(!ok) return;
    wbRows = [];
    saveWB();
    renderAll();
  });

  function updateChartOptions(){
    const groups=groupByProcess();
    const prev=chartSelect.value;
    chartSelect.innerHTML='';
    if(!groups.size){
      const opt=document.createElement('option');
      opt.value=''; opt.textContent=currentLang==='es'?'Sin procesos aún':'No process yet';
      chartSelect.appendChild(opt);
      drawTimeSeries(null,null);
      drawHistogram(null,null);
      return;
    }
    let first=null;
    [...groups.keys()].forEach(key=>{
      if(!first) first=key;
      const [p,m]=key.split('||');
      const opt=document.createElement('option');
      opt.value=key; opt.textContent=`${p} (${m})`;
      chartSelect.appendChild(opt);
    });
    chartSelect.value = (prev && groups.has(prev)) ? prev : first;
    renderCharts();
  }

  function renderCharts(){
    const key=chartSelect.value;
    const groups=groupByProcess();
    if(!key || !groups.has(key)){ drawTimeSeries(null,null); drawHistogram(null,null); return; }
    const arr=groups.get(key);
    const st=calcStats(arr);
    drawTimeSeries(arr,st);
    drawHistogram(arr,st);
  }

  function fitCanvas(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function drawTimeSeries(arr,st){
    fitCanvas(timeSeriesCanvas);
    const ctx=timeSeriesCanvas.getContext('2d');
    const w=timeSeriesCanvas.getBoundingClientRect().width;
    const h=timeSeriesCanvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#020b1a'; ctx.fillRect(0,0,w,h);

    if(!arr || !arr.length || !st || st.n<3){
      ctx.fillStyle='#607d8b'; ctx.font='12px system-ui';
      ctx.fillText(currentLang==='es'?'Se requieren al menos 3 muestras.':'Need at least 3 samples.',10,20);
      return;
    }

    const vals=st.values;
    let min=st.min, max=st.max;
    if(min===max){min-=0.5;max+=0.5;}
    const padL=35,padR=8,padT=10,padB=18;
    const innerW=w-padL-padR, innerH=h-padT-padB;

    const yScale=v=>padT+innerH*(1-(v-min)/(max-min));
    const xScale=i=>vals.length===1?(padL+innerW/2):(padL+innerW*(i/(vals.length-1)));

    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
    ctx.beginPath();
    for(let g=0;g<=4;g++){
      const y=padT+innerH*g/4;
      ctx.moveTo(padL,y); ctx.lineTo(w-padR,y);
    }
    ctx.stroke();

    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,h-padB); ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    ctx.fillStyle='#90a4ae'; ctx.font='10px system-ui';
    for(let g=0;g<=4;g++){
      const val=min+(max-min)*g/4;
      const y=padT+innerH*(1-g/4);
      ctx.fillText(formatSecs(val),2,y+3);
    }

    ctx.strokeStyle='#29b6f6'; ctx.lineWidth=2; ctx.beginPath();
    vals.forEach((v,i)=>{ const x=xScale(i), y=yScale(v); i?ctx.lineTo(x,y):ctx.moveTo(x,y); });
    ctx.stroke();

    ctx.fillStyle='#29b6f6';
    vals.forEach((v,i)=>{ const x=xScale(i), y=yScale(v); ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill(); });

    ctx.setLineDash([4,3]);
    if(st.std>0){
      const ucl=st.mean+3*st.std;
      const lcl=st.mean-3*st.std;
      ctx.strokeStyle='rgba(255,82,82,0.9)';
      ctx.beginPath();
      ctx.moveTo(padL,yScale(ucl)); ctx.lineTo(w-padR,yScale(ucl));
      ctx.moveTo(padL,yScale(lcl)); ctx.lineTo(w-padR,yScale(lcl));
      ctx.stroke();
    }
    ctx.strokeStyle='rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.moveTo(padL,yScale(st.mean)); ctx.lineTo(w-padR,yScale(st.mean)); ctx.stroke();

    ctx.strokeStyle='rgba(0,230,118,0.9)';
    ctx.beginPath(); ctx.moveTo(padL,yScale(st.median)); ctx.lineTo(w-padR,yScale(st.median)); ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawHistogram(arr,st){
    fitCanvas(histCanvas);
    const ctx=histCanvas.getContext('2d');
    const w=histCanvas.getBoundingClientRect().width;
    const h=histCanvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#020b1a'; ctx.fillRect(0,0,w,h);

    if(!arr || !arr.length || !st || st.n<3){
      ctx.fillStyle='#607d8b'; ctx.font='12px system-ui';
      ctx.fillText(currentLang==='es'?'Se requieren más muestras.':'Need more samples.',10,20);
      return;
    }

    const vals=st.values;
    let min=st.min, max=st.max;
    if(min===max){min-=0.5;max+=0.5;}
    const padL=30,padR=8,padT=8,padB=20;
    const innerW=w-padL-padR, innerH=h-padT-padB;
    const binsCount=8;
    const binSize=(max-min)/binsCount;
    const bins=new Array(binsCount).fill(0);
    vals.forEach(v=>{
      let idx=Math.floor((v-min)/binSize);
      if(idx===binsCount) idx=binsCount-1;
      bins[idx]++;
    });
    const maxBin=Math.max(...bins);

    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,h-padB); ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    const barW=innerW/binsCount;
    ctx.fillStyle='#29b6f6';
    bins.forEach((c,i)=>{
      const x=padL+i*barW+1;
      const barH=maxBin?innerH*(c/maxBin):0;
      const y=(h-padB)-barH;
      ctx.fillRect(x,y,barW-2,barH);
    });

    const medX=padL+innerW*((st.median-min)/(max-min));
    ctx.strokeStyle='#00e676';
    ctx.beginPath(); ctx.moveTo(medX,padT); ctx.lineTo(medX,h-padB); ctx.stroke();

    const p10x=padL+innerW*((st.p10-min)/(max-min));
    const p90x=padL+innerW*((st.p90-min)/(max-min));
    ctx.strokeStyle='rgba(255,241,118,0.9)';
    ctx.beginPath();
    ctx.moveTo(p10x,padT); ctx.lineTo(p10x,h-padB);
    ctx.moveTo(p90x,padT); ctx.lineTo(p90x,h-padB);
    ctx.stroke();
  }

  async function copyToClipboard(text){
    if(!text) return;
    try{ await navigator.clipboard.writeText(text); alert(currentLang==='es'?'Copiado.':'Copied.'); }
    catch(e){
      const ta=document.createElement('textarea'); ta.value=text;
      document.body.appendChild(ta); ta.select();
      try{ document.execCommand('copy'); alert(currentLang==='es'?'Copiado.':'Copied.'); }
      catch(err){ alert(currentLang==='es'?'No disponible el portapapeles.':'Clipboard not available.'); }
      document.body.removeChild(ta);
    }
  }

  btnCopyAll.addEventListener('click',()=>{
    if(!laps.length){ alert(currentLang==='es'?'No hay datos.':'No data.'); return; }
    const header = currentLang==='es'
      ? ['#','Proceso','Modo','Estatus','Nota','T1 (s)','T2 (s)','Total (s)']
      : ['#','Process','Mode','Status','Note','T1 (s)','T2 (s)','Total (s)'];

    const rows=laps.map((l,i)=>[
      i+1,l.process,l.mode,l.status||'',l.note||'',
      formatSecs(l.t1),formatSecs(l.t2),formatSecs(l.total)
    ].join('\t'));
    copyToClipboard(header.join('\t')+'\n'+rows.join('\n'));
  });

  btnCopySum.addEventListener('click',()=>{
    const lines=[];
    lines.push(currentLang==='es'?'Resumen (WB + Stats)':'Summary (WB + Stats)');
    lines.push('—');
    lines.push((currentLang==='es'?'Restricción: ':'Constraint: ')+wbConstraint.textContent);
    lines.push((currentLang==='es'?'Siguiente: ':'Next: ')+wbNextConstraint.textContent);
    lines.push((currentLang==='es'?'Operadores total: ':'Operators total: ')+wbOperatorsSum.textContent);
    lines.push('—');
    lines.push(currentLang==='es'?'WB (por operación):':'WB (by operation):');

    const enabled = wbRows.filter(r=>r.enabled).slice().sort((a,b)=>(a.seq||0)-(b.seq||0));
    enabled.forEach(r=>{
      const net = computeNetMinutes(r);
      const oee = computeOeePct(r);
      const ct = getCtTriple(r);
      const capOeeCur = computeCapacityPerDay(net, ct.cur)*oee;
      lines.push(`${r.seq} | ${r.operation||'(no name)'} | Cap@OEE ${formatUnits(capOeeCur)}/${currentLang==='es'?'día':'day'} | Contract ${formatUnits(r.contractPcd||0)} | Scrap ${pct(clamp(r.scrapPct,0,100),1)}`);
    });

    lines.push('—');
    lines.push(currentLang==='es'?'Nota: usa "Copy All" para datos crudos.':'Note: use "Copy All" for raw data.');
    copyToClipboard(lines.join('\n'));
  });

  function renderAll(){
    renderDataTable();
    renderFocusTable();
    renderStatsDetail();
    updateChartOptions();
    updateSemaphores();
    renderWB();
    methodGuideText.textContent = buildMethodGuide();
  }

  chartSelect.addEventListener('change',renderCharts);
  window.addEventListener('resize',renderCharts);

  [effInput, pcdInput, hInput, dInput, capViewSel, processInput, modeSelect].forEach(el=>{
    el.addEventListener('change',()=>{
      wbRows.forEach(r=>applyGlobalToRow(r));
      saveWB();
      renderAll();
    });
  });

  loadWB();
  updateDisplay();
  refreshRingStates();
  setLanguage(currentLang);
})();
</script>
</body>
</html>
